// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/

#ifndef _onvif_h_
#define _onvif_h_

#include <list>
#include <string>
#include <staff/common/WsdlTypes.h>
#include <staff/common/DataObject.h>
#include <staff/common/Attribute.h>
#include <staff/common/Optional.h>
#include <staff/common/QName.h>
#include <staff/utils/Base64Binary.h>
#include <staff/utils/HexBinary.h>
#include "xmlmime.h"
#include ".h"
#include "b.h"
#include "include.h"

// *interface.elementFormDefault: qualified
// *interface.targetNamespace: http://www.onvif.org/ver10/schema
// *interface.version: 2.3

  struct DeviceEntity;
  struct IntRectangle;
  struct IntRange;
  struct IntRectangleRange;
  struct FloatRange;
  struct DurationRange;
  struct IntList;
  struct FloatList;
  struct AnyHolder;
  struct VideoResolution;
  struct VideoSource;
  struct ImagingSettings;
  struct BacklightCompensation;
  struct Rectangle;
  struct Exposure;
  struct FocusConfiguration;
  struct WideDynamicRange;
  struct WhiteBalance;
  struct ImagingSettingsExtension;
  struct VideoSourceExtension;
  struct ImagingSettings20;
  struct BacklightCompensation20;
  struct Exposure20;
  struct FocusConfiguration20;
  struct FocusConfiguration20Extension;
  struct WideDynamicRange20;
  struct WhiteBalance20;
  struct WhiteBalance20Extension;
  struct ImagingSettingsExtension20;
  struct ImageStabilization;
  struct ImageStabilizationExtension;
  struct ImagingSettingsExtension202;
  struct VideoSourceExtension2;
  struct AudioSource;
  struct Profile;
  struct ConfigurationEntity;
  struct VideoSourceConfiguration;
  struct VideoSourceConfigurationExtension;
  struct Rotate;
  struct RotateExtension;
  struct VideoSourceConfigurationExtension2;
  struct AudioSourceConfiguration;
  struct IPAddress;
  struct MulticastConfiguration;
  struct VideoEncoderConfiguration;
  struct VideoRateControl;
  struct Mpeg4Configuration;
  struct H264Configuration;
  struct AudioEncoderConfiguration;
  struct AnalyticsEngineConfiguration;
  struct RuleEngineConfiguration;
  struct VideoAnalyticsConfiguration;
  struct ItemList;
  struct Config;
  struct ItemListExtension;
  struct AnalyticsEngineConfigurationExtension;
  struct RuleEngineConfigurationExtension;
  struct PTZConfiguration;
  struct PTZSpeed;
  struct Vector2D;
  struct Vector1D;
  struct Space2DDescription;
  struct PanTiltLimits;
  struct Space1DDescription;
  struct ZoomLimits;
  struct PTZConfigurationExtension;
  struct PTControlDirection;
  struct EFlip;
  struct Reverse;
  struct PTControlDirectionExtension;
  struct PTZConfigurationExtension2;
  struct MetadataConfiguration;
  struct PTZFilter;
  struct EventSubscription;
  struct MetadataConfigurationExtension;
  struct ProfileExtension;
  struct AudioOutputConfiguration;
  struct AudioDecoderConfiguration;
  struct ProfileExtension2;
  struct VideoSourceConfigurationOptions;
  struct VideoSourceConfigurationOptionsExtension;
  struct RotateOptions;
  struct RotateOptionsExtension;
  struct VideoSourceConfigurationOptionsExtension2;
  struct VideoEncoderConfigurationOptions;
  struct JpegOptions;
  struct Mpeg4Options;
  struct H264Options;
  struct VideoEncoderOptionsExtension;
  struct JpegOptions2;
  struct Mpeg4Options2;
  struct H264Options2;
  struct VideoEncoderOptionsExtension2;
  struct AudioSourceConfigurationOptions;
  struct AudioSourceOptionsExtension;
  struct AudioEncoderConfigurationOptions;
  struct AudioEncoderConfigurationOption;
  struct PTZStatusFilterOptions;
  struct MetadataConfigurationOptions;
  struct PTZStatusFilterOptionsExtension;
  struct Layout;
  struct VideoOutput;
  struct PaneLayout;
  struct LayoutExtension;
  struct VideoOutputExtension;
  struct VideoOutputConfiguration;
  struct VideoOutputConfigurationOptions;
  struct VideoDecoderConfigurationOptions;
  struct JpegDecOptions;
  struct H264DecOptions;
  struct Mpeg4DecOptions;
  struct VideoDecoderConfigurationOptionsExtension;
  struct AudioOutput;
  struct AudioOutputConfigurationOptions;
  struct AudioDecoderConfigurationOptions;
  struct AACDecOptions;
  struct G711DecOptions;
  struct G726DecOptions;
  struct AudioDecoderConfigurationOptionsExtension;
  struct Transport;
  struct StreamSetup;
  struct MediaUri;
  struct Scope;
  struct NetworkInterface;
  struct NetworkInterfaceInfo;
  struct NetworkInterfaceConnectionSetting;
  struct NetworkInterfaceLink;
  struct IPv4Configuration;
  struct IPv4NetworkInterface;
  struct PrefixedIPv4Address;
  struct IPv6NetworkInterface;
  struct IPv6Configuration;
  struct PrefixedIPv6Address;
  struct IPv6ConfigurationExtension;
  struct NetworkInterfaceExtension;
  struct Dot3Configuration;
  struct Dot11SecurityConfiguration;
  struct Dot11Configuration;
  struct Dot11PSKSet;
  struct Dot11PSKSetExtension;
  struct Dot11SecurityConfigurationExtension;
  struct NetworkInterfaceExtension2;
  struct NetworkProtocol;
  struct NetworkProtocolExtension;
  struct NetworkHost;
  struct NetworkHostExtension;
  struct HostnameInformation;
  struct HostnameInformationExtension;
  struct DNSInformation;
  struct DNSInformationExtension;
  struct NTPInformation;
  struct NTPInformationExtension;
  struct DynamicDNSInformation;
  struct DynamicDNSInformationExtension;
  struct NetworkInterfaceSetConfiguration;
  struct IPv4NetworkInterfaceSetConfiguration;
  struct IPv6NetworkInterfaceSetConfiguration;
  struct NetworkInterfaceSetConfigurationExtension;
  struct NetworkInterfaceSetConfigurationExtension2;
  struct NetworkGateway;
  struct NetworkZeroConfiguration;
  struct NetworkZeroConfigurationExtension;
  struct NetworkZeroConfigurationExtension2;
  struct IPAddressFilter;
  struct IPAddressFilterExtension;
  struct Dot11Capabilities;
  struct Dot11Status;
  struct Dot11AvailableNetworks;
  struct Dot11AvailableNetworksExtension;
  struct Capabilities;
  struct AnalyticsCapabilities;
  struct DeviceCapabilities;
  struct NetworkCapabilities;
  struct NetworkCapabilitiesExtension;
  struct NetworkCapabilitiesExtension2;
  struct SystemCapabilities;
  struct OnvifVersion;
  struct SystemCapabilitiesExtension;
  struct SystemCapabilitiesExtension2;
  struct IOCapabilities;
  struct IOCapabilitiesExtension2;
  struct IOCapabilitiesExtension;
  struct SecurityCapabilities;
  struct SecurityCapabilitiesExtension;
  struct SecurityCapabilitiesExtension2;
  struct DeviceCapabilitiesExtension;
  struct EventCapabilities;
  struct ImagingCapabilities;
  struct RealTimeStreamingCapabilities;
  struct MediaCapabilities;
  struct RealTimeStreamingCapabilitiesExtension;
  struct ProfileCapabilities;
  struct MediaCapabilitiesExtension;
  struct PTZCapabilities;
  struct CapabilitiesExtension;
  struct DeviceIOCapabilities;
  struct DisplayCapabilities;
  struct RecordingCapabilities;
  struct SearchCapabilities;
  struct ReplayCapabilities;
  struct ReceiverCapabilities;
  struct AnalyticsDeviceCapabilities;
  struct AnalyticsDeviceExtension;
  struct CapabilitiesExtension2;
  struct SystemLog;
  struct AttachmentData;
  struct SupportInformation;
  struct BinaryData;
  struct BackupFile;
  struct SystemLogUriList;
  struct SystemLogUri;
  struct SystemDateTime;
  struct TimeZone;
  struct Time;
  struct Date;
  struct DateTime;
  struct SystemDateTimeExtension;
  struct RemoteUser;
  struct User;
  struct UserExtension;
  struct CertificateGenerationParameters;
  struct CertificateGenerationParametersExtension;
  struct Certificate;
  struct CertificateStatus;
  struct CertificateWithPrivateKey;
  struct CertificateInformation;
  struct CertificateUsage;
  struct DateTimeRange;
  struct CertificateInformationExtension;
  struct Dot1XConfiguration;
  struct EAPMethodConfiguration;
  struct TLSConfiguration;
  struct EapMethodExtension;
  struct Dot1XConfigurationExtension;
  struct GenericEapPwdConfigurationExtension;
  struct RelayOutputSettings;
  struct RelayOutput;
  struct DigitalInput;
  struct PTZSpaces;
  struct PTZNode;
  struct PTZSpacesExtension;
  struct PTZPresetTourSupported;
  struct PTZNodeExtension;
  struct PTZPresetTourSupportedExtension;
  struct PTZNodeExtension2;
  struct PTZConfigurationOptions;
  struct PTControlDirectionOptions;
  struct EFlipOptions;
  struct EFlipOptionsExtension;
  struct ReverseOptions;
  struct ReverseOptionsExtension;
  struct PTControlDirectionOptionsExtension;
  struct PTZConfigurationOptions2;
  struct PTZVector;
  struct PTZStatus;
  struct PTZMoveStatus;
  struct PTZPreset;
  struct PTZPresetTourStatus;
  struct PTZPresetTourStartingCondition;
  struct PresetTour;
  struct PTZPresetTourPresetDetail;
  struct PTZPresetTourSpot;
  struct PTZPresetTourTypeExtension;
  struct PTZPresetTourSpotExtension;
  struct PTZPresetTourStatusExtension;
  struct PTZPresetTourStartingConditionExtension;
  struct PTZPresetTourExtension;
  struct PTZPresetTourStartingConditionOptions;
  struct PTZPresetTourPresetDetailOptions;
  struct PTZPresetTourSpotOptions;
  struct PTZPresetTourOptions;
  struct PTZPresetTourStartingConditionOptionsExtension;
  struct PTZPresetTourPresetDetailOptionsExtension;
  struct FocusStatus;
  struct ImagingStatus;
  struct BacklightCompensationOptions;
  struct ExposureOptions;
  struct FocusOptions;
  struct WideDynamicRangeOptions;
  struct WhiteBalanceOptions;
  struct ImagingOptions;
  struct FocusMove;
  struct AbsoluteFocus;
  struct RelativeFocus;
  struct ContinuousFocus;
  struct MoveOptions;
  struct AbsoluteFocusOptions;
  struct RelativeFocusOptions;
  struct ContinuousFocusOptions;
  struct ImagingStatus20;
  struct FocusStatus20;
  struct FocusStatus20Extension;
  struct ImagingStatus20Extension;
  struct ImagingOptions20;
  struct BacklightCompensationOptions20;
  struct ExposureOptions20;
  struct FocusOptions20;
  struct FocusOptions20Extension;
  struct WideDynamicRangeOptions20;
  struct WhiteBalanceOptions20;
  struct WhiteBalanceOptions20Extension;
  struct ImagingOptions20Extension;
  struct ImageStabilizationOptions;
  struct ImageStabilizationOptionsExtension;
  struct ImagingOptions20Extension2;
  struct MoveOptions20;
  struct RelativeFocusOptions20;
  struct MessageExtension;
  struct MessageDescription;
  struct ItemListDescription;
  struct ItemListDescriptionExtension;
  struct MessageDescriptionExtension;
  struct Vector;
  struct Polygon;
  struct Polyline;
  struct Color;
  struct ColorCovariance;
  struct Appearance;
  struct Transformation;
  struct TransformationExtension;
  struct ShapeDescriptor;
  struct ShapeDescriptorExtension;
  struct ColorDescriptor;
  struct ColorDescriptorExtension;
  struct ClassDescriptor;
  struct ClassDescriptorExtension;
  struct OtherType;
  struct ClassDescriptorExtension2;
  struct AppearanceExtension;
  struct ObjectId;
  struct Object;
  struct Behaviour;
  struct BehaviourExtension;
  struct ObjectExtension;
  struct Frame;
  struct ObjectTree;
  struct Rename;
  struct Split;
  struct Merge;
  struct ObjectTreeExtension;
  struct FrameExtension;
  struct MotionInCells;
  struct FrameExtension2;
  struct ConfigDescription;
  struct ConfigDescriptionExtension;
  struct SupportedRules;
  struct SupportedRulesExtension;
  struct SupportedAnalyticsModules;
  struct SupportedAnalyticsModulesExtension;
  struct PolygonConfiguration;
  struct PolylineArray;
  struct PolylineArrayExtension;
  struct PolylineArrayConfiguration;
  struct MotionExpression;
  struct MotionExpressionConfiguration;
  struct CellLayout;
  struct MetadataStreamItem;
  struct VideoAnalyticsStreamItem;
  struct VideoAnalyticsStreamExtension;
  struct PTZStreamItem;
  struct PTZStreamExtension;
  struct EventStreamItem;
  struct EventStreamExtension;
  struct MetadataStreamExtension;
  struct PaneConfiguration;
  struct CodingCapabilities;
  struct LayoutOptions;
  struct PaneLayoutOptions;
  struct PaneOptionExtension;
  struct LayoutOptionsExtension;
  struct ReceiverConfiguration;
  struct Receiver;
  struct ReceiverStateInformation;
  struct SourceReference;
  struct RecordingSummary;
  struct SearchScope;
  struct SearchScopeExtension;
  struct EventFilter;
  struct PTZPositionFilter;
  struct MetadataFilter;
  struct FindRecordingResultList;
  struct RecordingSourceInformation;
  struct RecordingInformation;
  struct TrackInformation;
  struct FindEventResultList;
  struct FindEventResult;
  struct FindPTZPositionResultList;
  struct FindPTZPositionResult;
  struct FindMetadataResultList;
  struct FindMetadataResult;
  struct MediaAttributes;
  struct TrackAttributes;
  struct VideoAttributes;
  struct AudioAttributes;
  struct MetadataAttributes;
  struct TrackAttributesExtension;
  struct RecordingConfiguration;
  struct TrackConfiguration;
  struct GetTracksResponseList;
  struct GetRecordingsResponseItem;
  struct GetTracksResponseItem;
  struct RecordingJobConfiguration;
  struct RecordingJobSource;
  struct RecordingJobTrack;
  struct RecordingJobSourceExtension;
  struct RecordingJobConfigurationExtension;
  struct RecordingJobStateInformation;
  struct RecordingJobStateTracks;
  struct RecordingJobStateSource;
  struct RecordingJobStateTrack;
  struct RecordingJobStateInformationExtension;
  struct GetRecordingJobsResponseItem;
  struct ReplayConfiguration;
  struct AnalyticsDeviceEngineConfiguration;
  struct AnalyticsEngine;
  struct AnalyticsEngineInputInfo;
  struct EngineConfiguration;
  struct AnalyticsEngineInputInfoExtension;
  struct AnalyticsDeviceEngineConfigurationExtension;
  struct SourceIdentification;
  struct MetadataInput;
  struct AnalyticsEngineInput;
  struct SourceIdentificationExtension;
  struct MetadataInputExtension;
  struct AnalyticsEngineControl;
  struct AnalyticsState;
  struct AnalyticsStateInformation;
  struct ActionEngineEventPayload;
  struct ActionEngineEventPayloadExtension;
  struct Message;


  // *restriction-maxLength: 64
  typedef std::string ReferenceToken;  //!< Unique identifier for a physical or logical resource.

  // *restriction-maxLength: 64
  typedef std::string Name;  //!< User readable name.

  // *restriction-list: xs:int
  typedef std::string IntAttrList;

  // *restriction-list: xs:float
  typedef std::string FloatAttrList;

  // *restriction-list: xs:string
  typedef std::string StringAttrList;

  // *restriction-maxInclusive: 31
  // *restriction-minInclusive: 0
  typedef int NetworkInterfaceConfigPriority;

  // *elementName: IANA-IfTypes
  typedef int IANA_IfTypes;
  typedef staff::token IPv4Address;
  typedef staff::token IPv6Address;
  typedef staff::token HwAddress;
  typedef staff::token DNSName;
  typedef staff::token Domain;

  // *restriction-maxLength: 32
  // *restriction-minLength: 1
  typedef staff::hexBinary Dot11SSIDType;

  // *restriction-length: 32
  typedef staff::hexBinary Dot11PSK;

  // *restriction-pattern: [ -~]{8,63}
  typedef std::string Dot11PSKPassphrase;

  // *restriction-maxLength: 128
  typedef std::string AuxiliaryData;
  typedef staff::anyURI TopicNamespaceLocation;
  typedef ::ReferenceToken ReceiverReference;
  typedef ::ReferenceToken RecordingReference;
  typedef ::ReferenceToken TrackReference;
  typedef std::string XPathExpression;
  typedef ::ReferenceToken JobToken;
  typedef ::ReferenceToken RecordingJobReference;
  typedef std::string RecordingJobMode;
  typedef std::string RecordingJobState;

  // *useParentElement: true
  typedef std::list< ::MetadataStreamItem > MetadataStream;

  // *useParentElement: true
  typedef std::list< ::VideoAnalyticsStreamItem > VideoAnalyticsStream;

  // *useParentElement: true
  typedef std::list< ::PTZStreamItem > PTZStream;

  // *useParentElement: true
  typedef std::list< ::EventStreamItem > EventStream;

  // *baseType: string
  // *renamed: true
  enum RotateMode
  {
    // *value: OFF
    RotateMode_OFF,
    // *value: ON
    RotateMode_ON,
    // *value: AUTO
    RotateMode_AUTO
  };

  // *baseType: string
  // *renamed: true
  enum VideoEncoding
  {
    // *value: JPEG
    VideoEncoding_JPEG,
    // *value: MPEG4
    VideoEncoding_MPEG4,
    // *value: H264
    VideoEncoding_H264
  };

  // *baseType: string
  // *renamed: true
  enum Mpeg4Profile
  {
    // *value: SP
    Mpeg4Profile_SP,
    // *value: ASP
    Mpeg4Profile_ASP
  };

  // *baseType: string
  // *renamed: true
  enum H264Profile
  {
    // *value: Baseline
    H264Profile_Baseline,
    // *value: Main
    H264Profile_Main,
    // *value: Extended
    H264Profile_Extended,
    // *value: High
    H264Profile_High
  };

  // *baseType: string
  // *renamed: true
  enum AudioEncoding
  {
    // *value: G711
    AudioEncoding_G711,
    // *value: G726
    AudioEncoding_G726,
    // *value: AAC
    AudioEncoding_AAC
  };

  // *baseType: string
  // *renamed: true
  enum StreamType
  {
    // *value: RTP-Unicast
    StreamType_RTP_Unicast,
    // *value: RTP-Multicast
    StreamType_RTP_Multicast
  };

  // *baseType: string
  // *renamed: true
  enum TransportProtocol
  {
    // *value: UDP
    TransportProtocol_UDP,
    // *value: TCP
    TransportProtocol_TCP,
    // *value: RTSP
    TransportProtocol_RTSP,
    // *value: HTTP
    TransportProtocol_HTTP
  };

  // *baseType: string
  // *renamed: true
  enum ScopeDefinition
  {
    // *value: Fixed
    ScopeDefinition_Fixed,
    // *value: Configurable
    ScopeDefinition_Configurable
  };

  // *baseType: string
  // *renamed: true
  enum DiscoveryMode
  {
    // *value: Discoverable
    DiscoveryMode_Discoverable,
    // *value: NonDiscoverable
    DiscoveryMode_NonDiscoverable
  };

  // *baseType: string
  // *renamed: true
  enum Duplex
  {
    // *value: Full
    Duplex_Full,
    // *value: Half
    Duplex_Half
  };

  // *baseType: string
  // *renamed: true
  enum IPv6DHCPConfiguration
  {
    // *value: Auto
    IPv6DHCPConfiguration_Auto,
    // *value: Stateful
    IPv6DHCPConfiguration_Stateful,
    // *value: Stateless
    IPv6DHCPConfiguration_Stateless,
    // *value: Off
    IPv6DHCPConfiguration_Off
  };

  // *baseType: string
  // *renamed: true
  enum NetworkProtocolType
  {
    // *value: HTTP
    NetworkProtocolType_HTTP,
    // *value: HTTPS
    NetworkProtocolType_HTTPS,
    // *value: RTSP
    NetworkProtocolType_RTSP
  };

  // *baseType: string
  // *renamed: true
  enum NetworkHostType
  {
    // *value: IPv4
    NetworkHostType_IPv4,
    // *value: IPv6
    NetworkHostType_IPv6,
    // *value: DNS
    NetworkHostType_DNS
  };

  // *baseType: string
  // *renamed: true
  enum IPType
  {
    // *value: IPv4
    IPType_IPv4,
    // *value: IPv6
    IPType_IPv6
  };

  // *baseType: string
  // *renamed: true
  enum IPAddressFilterType
  {
    // *value: Allow
    IPAddressFilterType_Allow,
    // *value: Deny
    IPAddressFilterType_Deny
  };

  // *baseType: string
  // *renamed: true
  enum DynamicDNSType
  {
    // *value: NoUpdate
    DynamicDNSType_NoUpdate,
    // *value: ClientUpdates
    DynamicDNSType_ClientUpdates,
    // *value: ServerUpdates
    DynamicDNSType_ServerUpdates
  };

  // *baseType: string
  // *renamed: true
  enum Dot11StationMode
  {
    // *value: Ad-hoc
    Dot11StationMode_Ad_hoc,
    // *value: Infrastructure
    Dot11StationMode_Infrastructure,
    // *value: Extended
    Dot11StationMode_Extended
  };

  // *baseType: string
  // *renamed: true
  enum Dot11SecurityMode
  {
    // *value: None
    Dot11SecurityMode_None,
    // *value: WEP
    Dot11SecurityMode_WEP,
    // *value: PSK
    Dot11SecurityMode_PSK,
    // *value: Dot1X
    Dot11SecurityMode_Dot1X,
    // *value: Extended
    Dot11SecurityMode_Extended
  };

  // *baseType: string
  // *renamed: true
  enum Dot11Cipher
  {
    // *value: CCMP
    Dot11Cipher_CCMP,
    // *value: TKIP
    Dot11Cipher_TKIP,
    // *value: Any
    Dot11Cipher_Any,
    // *value: Extended
    Dot11Cipher_Extended
  };

  // *baseType: string
  // *renamed: true
  enum Dot11SignalStrength
  {
    // *value: None
    Dot11SignalStrength_None,
    // *value: Very Bad
    Dot11SignalStrength_Very_Bad,
    // *value: Bad
    Dot11SignalStrength_Bad,
    // *value: Good
    Dot11SignalStrength_Good,
    // *value: Very Good
    Dot11SignalStrength_Very_Good,
    // *value: Extended
    Dot11SignalStrength_Extended
  };

  // *baseType: string
  // *renamed: true
  enum Dot11AuthAndMangementSuite
  {
    // *value: None
    Dot11AuthAndMangementSuite_None,
    // *value: Dot1X
    Dot11AuthAndMangementSuite_Dot1X,
    // *value: PSK
    Dot11AuthAndMangementSuite_PSK,
    // *value: Extended
    Dot11AuthAndMangementSuite_Extended
  };

  // *baseType: string
  // *renamed: true
  enum CapabilityCategory
  {
    // *value: All
    CapabilityCategory_All,
    // *value: Analytics
    CapabilityCategory_Analytics,
    // *value: Device
    CapabilityCategory_Device,
    // *value: Events
    CapabilityCategory_Events,
    // *value: Imaging
    CapabilityCategory_Imaging,
    // *value: Media
    CapabilityCategory_Media,
    // *value: PTZ
    CapabilityCategory_PTZ
  };

  //! Enumeration describing the available system log modes.
  // *baseType: string
  // *renamed: true
  enum SystemLogType
  {
    // *value: System
    SystemLogType_System, //!< Indicates that a system log is requested.
    // *value: Access
    SystemLogType_Access //!< Indicates that a access log is requested.
  };

  //! Enumeration describing the available factory default modes.
  // *baseType: string
  // *renamed: true
  enum FactoryDefaultType
  {
    // *value: Hard
    FactoryDefaultType_Hard, //!< Indicates that a hard factory default is requested.
    // *value: Soft
    FactoryDefaultType_Soft //!< Indicates that a soft factory default is requested.
  };

  // *baseType: string
  // *renamed: true
  enum SetDateTimeType
  {
    // *value: Manual
    SetDateTimeType_Manual, //!< Indicates that the date and time are set manually.
    // *value: NTP
    SetDateTimeType_NTP //!< Indicates that the date and time are set through NTP
  };

  // *baseType: string
  // *renamed: true
  enum UserLevel
  {
    // *value: Administrator
    UserLevel_Administrator,
    // *value: Operator
    UserLevel_Operator,
    // *value: User
    UserLevel_User,
    // *value: Anonymous
    UserLevel_Anonymous,
    // *value: Extended
    UserLevel_Extended
  };

  // *baseType: string
  // *renamed: true
  enum RelayLogicalState
  {
    // *value: active
    RelayLogicalState_active,
    // *value: inactive
    RelayLogicalState_inactive
  };

  // *baseType: string
  // *renamed: true
  enum RelayIdleState
  {
    // *value: closed
    RelayIdleState_closed,
    // *value: open
    RelayIdleState_open
  };

  // *baseType: string
  // *renamed: true
  enum RelayMode
  {
    // *value: Monostable
    RelayMode_Monostable,
    // *value: Bistable
    RelayMode_Bistable
  };

  // *baseType: string
  // *renamed: true
  enum EFlipMode
  {
    // *value: OFF
    EFlipMode_OFF,
    // *value: ON
    EFlipMode_ON,
    // *value: Extended
    EFlipMode_Extended
  };

  // *baseType: string
  // *renamed: true
  enum ReverseMode
  {
    // *value: OFF
    ReverseMode_OFF,
    // *value: ON
    ReverseMode_ON,
    // *value: AUTO
    ReverseMode_AUTO,
    // *value: Extended
    ReverseMode_Extended
  };

  // *baseType: string
  // *renamed: true
  enum MoveStatus
  {
    // *value: IDLE
    MoveStatus_IDLE,
    // *value: MOVING
    MoveStatus_MOVING,
    // *value: UNKNOWN
    MoveStatus_UNKNOWN
  };

  // *baseType: string
  // *renamed: true
  enum PTZPresetTourState
  {
    // *value: Idle
    PTZPresetTourState_Idle,
    // *value: Touring
    PTZPresetTourState_Touring,
    // *value: Paused
    PTZPresetTourState_Paused,
    // *value: Extended
    PTZPresetTourState_Extended
  };

  // *baseType: string
  // *renamed: true
  enum PTZPresetTourDirection
  {
    // *value: Forward
    PTZPresetTourDirection_Forward,
    // *value: Backward
    PTZPresetTourDirection_Backward,
    // *value: Extended
    PTZPresetTourDirection_Extended
  };

  // *baseType: string
  // *renamed: true
  enum PTZPresetTourOperation
  {
    // *value: Start
    PTZPresetTourOperation_Start,
    // *value: Stop
    PTZPresetTourOperation_Stop,
    // *value: Pause
    PTZPresetTourOperation_Pause,
    // *value: Extended
    PTZPresetTourOperation_Extended
  };

  // *baseType: string
  // *renamed: true
  enum AutoFocusMode
  {
    // *value: AUTO
    AutoFocusMode_AUTO,
    // *value: MANUAL
    AutoFocusMode_MANUAL
  };

  // *baseType: string
  // *renamed: true
  enum WideDynamicMode
  {
    // *value: OFF
    WideDynamicMode_OFF,
    // *value: ON
    WideDynamicMode_ON
  };

  //! Enumeration describing the available backlight compenstation modes.
  // *baseType: string
  // *renamed: true
  enum BacklightCompensationMode
  {
    // *value: OFF
    BacklightCompensationMode_OFF, //!< Backlight compensation is disabled.
    // *value: ON
    BacklightCompensationMode_ON //!< Backlight compensation is enabled.
  };

  // *baseType: string
  // *renamed: true
  enum ExposurePriority
  {
    // *value: LowNoise
    ExposurePriority_LowNoise,
    // *value: FrameRate
    ExposurePriority_FrameRate
  };

  // *baseType: string
  // *renamed: true
  enum ExposureMode
  {
    // *value: AUTO
    ExposureMode_AUTO,
    // *value: MANUAL
    ExposureMode_MANUAL
  };

  // *baseType: string
  // *renamed: true
  enum Enabled
  {
    // *value: ENABLED
    Enabled_ENABLED,
    // *value: DISABLED
    Enabled_DISABLED
  };

  // *baseType: string
  // *renamed: true
  enum WhiteBalanceMode
  {
    // *value: AUTO
    WhiteBalanceMode_AUTO,
    // *value: MANUAL
    WhiteBalanceMode_MANUAL
  };

  // *baseType: string
  // *renamed: true
  enum IrCutFilterMode
  {
    // *value: ON
    IrCutFilterMode_ON,
    // *value: OFF
    IrCutFilterMode_OFF,
    // *value: AUTO
    IrCutFilterMode_AUTO
  };

  // *baseType: string
  // *renamed: true
  enum ImageStabilizationMode
  {
    // *value: OFF
    ImageStabilizationMode_OFF,
    // *value: ON
    ImageStabilizationMode_ON,
    // *value: AUTO
    ImageStabilizationMode_AUTO,
    // *value: Extended
    ImageStabilizationMode_Extended
  };

  // *baseType: string
  // *renamed: true
  enum PropertyOperation
  {
    // *value: Initialized
    PropertyOperation_Initialized,
    // *value: Deleted
    PropertyOperation_Deleted,
    // *value: Changed
    PropertyOperation_Changed
  };

  // *baseType: string
  // *renamed: true
  enum Direction
  {
    // *value: Left
    Direction_Left,
    // *value: Right
    Direction_Right,
    // *value: Any
    Direction_Any
  };

  // *baseType: string
  // *renamed: true
  enum ClassType
  {
    // *value: Animal
    ClassType_Animal,
    // *value: Face
    ClassType_Face,
    // *value: Human
    ClassType_Human,
    // *value: Vehical
    ClassType_Vehical,
    // *value: Other
    ClassType_Other
  };

  //! Specifies a receiver connection mode.
  // *baseType: string
  // *renamed: true
  enum ReceiverMode
  {
    // *value: AutoConnect
    ReceiverMode_AutoConnect, //!< The receiver connects on demand, as required by consumers of the media streams.
    // *value: AlwaysConnect
    ReceiverMode_AlwaysConnect, //!< The receiver attempts to maintain a persistent connection to the configured endpoint.
    // *value: NeverConnect
    ReceiverMode_NeverConnect, //!< The receiver does not attempt to connect.
    // *value: Unknown
    ReceiverMode_Unknown //!< This case should never happen.
  };

  //! Specifies the current connection state of the receiver.
  // *baseType: string
  // *renamed: true
  enum ReceiverState
  {
    // *value: NotConnected
    ReceiverState_NotConnected, //!< The receiver is not connected.
    // *value: Connecting
    ReceiverState_Connecting, //!< The receiver is attempting to connect.
    // *value: Connected
    ReceiverState_Connected, //!< The receiver is connected.
    // *value: Unknown
    ReceiverState_Unknown //!< This case should never happen.
  };

  // *baseType: string
  // *renamed: true
  enum SearchState
  {
    // *value: Queued
    SearchState_Queued, //!< The search is queued and not yet started.
    // *value: Searching
    SearchState_Searching, //!< The search is underway and not yet completed.
    // *value: Completed
    SearchState_Completed, //!< The search has been completed and no new results will be found.
    // *value: Unknown
    SearchState_Unknown //!< The state of the search is unknown. (This is not a valid response from GetSearchState.)
  };

  // *baseType: string
  // *renamed: true
  enum RecordingStatus
  {
    // *value: Initiated
    RecordingStatus_Initiated,
    // *value: Recording
    RecordingStatus_Recording,
    // *value: Stopped
    RecordingStatus_Stopped,
    // *value: Removing
    RecordingStatus_Removing,
    // *value: Removed
    RecordingStatus_Removed,
    // *value: Unknown
    RecordingStatus_Unknown //!< This case should never happen.
  };

  // *baseType: string
  // *renamed: true
  enum TrackType
  {
    // *value: Video
    TrackType_Video,
    // *value: Audio
    TrackType_Audio,
    // *value: Metadata
    TrackType_Metadata,
    // *value: Extended
    TrackType_Extended //!< Placeholder for future extension.
  };

  // *baseType: string
  // *renamed: true
  enum ModeOfOperation
  {
    // *value: Idle
    ModeOfOperation_Idle,
    // *value: Active
    ModeOfOperation_Active,
    // *value: Unknown
    ModeOfOperation_Unknown //!< This case should never happen.
  };

  //! Base class for physical entities like inputs and outputs.
  struct DeviceEntity
  {
    // *isAttribute: true
    ::ReferenceToken token;  //!< Unique identifier referencing the physical entity.
  };

  //! Rectangle defined by lower left corner position and size.
  /*! Units are pixel. */
  struct IntRectangle
  {
    // *isAttribute: true
    int x;
    // *isAttribute: true
    int y;
    // *isAttribute: true
    int width;
    // *isAttribute: true
    int height;
  };

  //! Range of values greater equal Min value and less equal Max value.
  struct IntRange
  {
    int Min;
    int Max;
  };

  //! Range of a rectangle.
  /*! The rectangle itself is defined by lower left corner position and size. Units are pixel. */
  struct IntRectangleRange
  {
    ::IntRange XRange;  //!< Range of X-axis.
    ::IntRange YRange;  //!< Range of Y-axis.
    ::IntRange WidthRange;  //!< Range of width.
    ::IntRange HeightRange;  //!< Range of height.
  };

  //! Range of values greater equal Min value and less equal Max value.
  struct FloatRange
  {
    float Min;
    float Max;
  };

  //! Range of duration greater equal Min duration and less equal Max duration.
  struct DurationRange
  {
    staff::duration Min;
    staff::duration Max;
  };

  //! List of values.
  struct IntList
  {
    // *useParentElement: true
    std::list<int> Items;
  };

  struct FloatList
  {
    // *useParentElement: true
    std::list<float> Items;
  };

  struct AnyHolder
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct VideoResolution
  {
    int Width;  //!< Number of the columns of the Video image.
    int Height;  //!< Number of the lines of the Video image.
  };

  //! Representation of a physical video input.
  struct VideoSource: public ::DeviceEntity
  {
    float Framerate;  //!< Frame rate in frames per second.
    ::VideoResolution Resolution;  //!< Horizontal and vertical resolution
    staff::Optional< ::ImagingSettings > Imaging;  //!< Optional configuration of the image sensor.
    staff::Optional< ::VideoSourceExtension > Extension;
  };

  struct ImagingSettings
  {
    staff::Optional< ::BacklightCompensation > BacklightCompensation;  //!< Enabled/disabled BLC mode (on/off).
    staff::Optional<float> Brightness;  //!< Image brightness (unit unspecified).
    staff::Optional<float> ColorSaturation;  //!< Color saturation of the image (unit unspecified).
    staff::Optional<float> Contrast;  //!< Contrast of the image (unit unspecified).
    staff::Optional< ::Exposure > Exposure;  //!< Exposure mode of the device.
    staff::Optional< ::FocusConfiguration > Focus;  //!< Focus configuration.
    staff::Optional< ::IrCutFilterMode > IrCutFilter;  //!< Infrared Cutoff Filter settings.
    staff::Optional<float> Sharpness;  //!< Sharpness of the Video image.
    staff::Optional< ::WideDynamicRange > WideDynamicRange;  //!< WDR settings.
    staff::Optional< ::WhiteBalance > WhiteBalance;  //!< White balance settings.
    staff::Optional< ::ImagingSettingsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct BacklightCompensation
  {
    ::BacklightCompensationMode Mode;  //!< Backlight compensation mode (on/off).
    float Level;  //!< Optional level parameter (unit unspecified).
  };

  struct Rectangle
  {
    // *isAttribute: true
    staff::Optional<float> bottom;
    // *isAttribute: true
    staff::Optional<float> top;
    // *isAttribute: true
    staff::Optional<float> right;
    // *isAttribute: true
    staff::Optional<float> left;
  };

  struct Exposure
  {
    ::ExposureMode Mode;  //!< Exposure Mode
    ::ExposurePriority Priority;  //!< The exposure priority mode (low noise/framerate).
    ::Rectangle Window;  //!< Rectangular exposure mask.
    float MinExposureTime;  //!< Minimum value of exposure time range allowed to be used by the algorithm.
    float MaxExposureTime;  //!< Maximum value of exposure time range allowed to be used by the algorithm.
    float MinGain;  //!< Minimum value of the sensor gain range that is allowed to be used by the algorithm.
    float MaxGain;  //!< Maximum value of the sensor gain range that is allowed to be used by the algorithm.
    float MinIris;  //!< Minimum value of the iris range allowed to be used by the algorithm.
    float MaxIris;  //!< Maximum value of the iris range allowed to be used by the algorithm.
    float ExposureTime;  //!< The fixed exposure time used by the image sensor (ºs).
    float Gain;  //!< The fixed gain used by the image sensor (dB).
    float Iris;  //!< The fixed attenuation of input light affected by the iris (dB).
  };

  struct FocusConfiguration
  {
    ::AutoFocusMode AutoFocusMode;
    float DefaultSpeed;
    float NearLimit;  //!< Parameter to set autofocus near limit (unit: meter).
    float FarLimit;  //!< Parameter to set autofocus far limit (unit: meter).
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct WideDynamicRange
  {
    ::WideDynamicMode Mode;  //!< White dynamic range (on/off)
    float Level;  //!< Optional level parameter (unitless)
  };

  struct WhiteBalance
  {
    ::WhiteBalanceMode Mode;  //!< Auto whitebalancing mode (auto/manual).
    float CrGain;  //!< Rgain (unitless).
    float CbGain;  //!< Bgain (unitless).
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ImagingSettingsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoSourceExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::ImagingSettings20 > Imaging;  //!< Optional configuration of the image sensor.
    staff::Optional< ::VideoSourceExtension2 > Extension;
  };

  //! Type describing the ImagingSettings of a VideoSource.
  /*! The supported options and ranges can be obtained via the GetOptions command. */
  struct ImagingSettings20
  {
    staff::Optional< ::BacklightCompensation20 > BacklightCompensation;  //!< Enabled/disabled BLC mode (on/off).
    staff::Optional<float> Brightness;  //!< Image brightness (unit unspecified).
    staff::Optional<float> ColorSaturation;  //!< Color saturation of the image (unit unspecified).
    staff::Optional<float> Contrast;  //!< Contrast of the image (unit unspecified).
    staff::Optional< ::Exposure20 > Exposure;  //!< Exposure mode of the device.
    staff::Optional< ::FocusConfiguration20 > Focus;  //!< Focus configuration.
    staff::Optional< ::IrCutFilterMode > IrCutFilter;  //!< Infrared Cutoff Filter settings.
    staff::Optional<float> Sharpness;  //!< Sharpness of the Video image.
    staff::Optional< ::WideDynamicRange20 > WideDynamicRange;  //!< WDR settings.
    staff::Optional< ::WhiteBalance20 > WhiteBalance;  //!< White balance settings.
    staff::Optional< ::ImagingSettingsExtension20 > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  //! Type describing whether BLC mode is enabled or disabled (on/off).
  struct BacklightCompensation20
  {
    ::BacklightCompensationMode Mode;  //!< Backlight compensation mode (on/off).
    staff::Optional<float> Level;  //!< Optional level parameter (unit unspecified).
  };

  //! Type describing the exposure settings.
  struct Exposure20
  {
    ::ExposureMode Mode;  //!< Exposure Mode
    staff::Optional< ::ExposurePriority > Priority;  //!< The exposure priority mode (low noise/framerate).
    staff::Optional< ::Rectangle > Window;  //!< Rectangular exposure mask.
    staff::Optional<float> MinExposureTime;  //!< Minimum value of exposure time range allowed to be used by the algorithm.
    staff::Optional<float> MaxExposureTime;  //!< Maximum value of exposure time range allowed to be used by the algorithm.
    staff::Optional<float> MinGain;  //!< Minimum value of the sensor gain range that is allowed to be used by the algorithm.
    staff::Optional<float> MaxGain;  //!< Maximum value of the sensor gain range that is allowed to be used by the algorithm.
    staff::Optional<float> MinIris;  //!< Minimum value of the iris range allowed to be used by the algorithm.
    staff::Optional<float> MaxIris;  //!< Maximum value of the iris range allowed to be used by the algorithm.
    staff::Optional<float> ExposureTime;  //!< The fixed exposure time used by the image sensor (ºs).
    staff::Optional<float> Gain;  //!< The fixed gain used by the image sensor (dB).
    staff::Optional<float> Iris;  //!< The fixed attenuation of input light affected by the iris (dB).
  };

  struct FocusConfiguration20
  {
    ::AutoFocusMode AutoFocusMode;  //!< Mode of auto fucus.
    staff::Optional<float> DefaultSpeed;
    staff::Optional<float> NearLimit;  //!< Parameter to set autofocus near limit (unit: meter).
    staff::Optional<float> FarLimit;  //!< Parameter to set autofocus far limit (unit: meter).
    staff::Optional< ::FocusConfiguration20Extension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct FocusConfiguration20Extension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  //! Type describing whether WDR mode is enabled or disabled (on/off).
  struct WideDynamicRange20
  {
    ::WideDynamicMode Mode;  //!< Wide dynamic range mode (on/off).
    staff::Optional<float> Level;  //!< Optional level parameter (unit unspecified).
  };

  struct WhiteBalance20
  {
    ::WhiteBalanceMode Mode;  //!< 'AUTO' or 'MANUAL'
    staff::Optional<float> CrGain;  //!< Rgain (unitless).
    staff::Optional<float> CbGain;  //!< Bgain (unitless).
    staff::Optional< ::WhiteBalance20Extension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct WhiteBalance20Extension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ImagingSettingsExtension20
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::ImageStabilization > ImageStabilization;  //!< Optional element to configure Image Stabilization feature.
    staff::Optional< ::ImagingSettingsExtension202 > Extension;
  };

  struct ImageStabilization
  {
    ::ImageStabilizationMode Mode;  //!< Parameter to enable/disable Image Stabilization feature.
    staff::Optional<float> Level;  //!< Optional level parameter (unit unspecified)
    staff::Optional< ::ImageStabilizationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ImageStabilizationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ImagingSettingsExtension202
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoSourceExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  //! Representation of a physical audio input.
  struct AudioSource: public ::DeviceEntity
  {
    int Channels;  //!< number of available audio channels.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  //! A media profile consists of a set of media configurations.
  /*! Media profiles are used by a client
			to configure properties of a media stream from an NVT. An NVT shall provide at least one media profile at boot. An NVT should provide ‚Äúready to use‚Äù
			profiles for the most common media configurations that the device offers. A profile consists of a set of interconnected configuration entities. Configurations are provided
			by the NVT and can be either static or created dynamically by the NVT. For example, the
			dynamic configurations can be created by the NVT depending on current available encoding
			resources. */
  struct Profile
  {
    ::Name Name;  //!< User readable name of the profile.
    staff::Optional< ::VideoSourceConfiguration > VideoSourceConfiguration;  //!< Optional configuration of the Video input.
    staff::Optional< ::AudioSourceConfiguration > AudioSourceConfiguration;  //!< Optional configuration of the Audio input.
    staff::Optional< ::VideoEncoderConfiguration > VideoEncoderConfiguration;  //!< Optional configuration of the Video encoder.
    staff::Optional< ::AudioEncoderConfiguration > AudioEncoderConfiguration;  //!< Optional configuration of the Audio encoder.
    staff::Optional< ::VideoAnalyticsConfiguration > VideoAnalyticsConfiguration;  //!< Optional configuration of the video analytics module and rule engine.
    staff::Optional< ::PTZConfiguration > PTZConfiguration;  //!< Optional configuration of the pan tilt zoom unit.
    staff::Optional< ::MetadataConfiguration > MetadataConfiguration;  //!< Optional configuration of the metadata stream.
    staff::Optional< ::ProfileExtension > Extension;  //!< Extensions defined in ONVIF 2.0
    staff::anyAttribute lsAnyAttributes;
    // *isAttribute: true
    ::ReferenceToken token;  //!< Unique identifier of the profile.
    // *isAttribute: true
    staff::Optional<bool> fixed;  //!< A value of true signals that the profile cannot be deleted.
  };

  //! Base type defining the common properties of a configuration.
  struct ConfigurationEntity
  {
    ::Name Name;  //!< User readable name.
    int UseCount;  //!< Number of internal references currently using this configuration.
    // *isAttribute: true
    ::ReferenceToken token;  //!< Token that uniquely refernces this configuration.
  };

  struct VideoSourceConfiguration: public ::ConfigurationEntity
  {
    ::ReferenceToken SourceToken;  //!< Reference to the physical input.
    ::IntRectangle Bounds;  //!< Rectangle specifying the Video capturing area.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::VideoSourceConfigurationExtension > Extension;
  };

  struct VideoSourceConfigurationExtension
  {
    staff::Optional< ::Rotate > Rotate;  //!< Optional element to configure rotation of captured image.
    staff::Optional< ::VideoSourceConfigurationExtension2 > Extension;
  };

  struct Rotate
  {
    ::RotateMode Mode;  //!< Parameter to enable/disable Rotation feature.
    staff::Optional<int> Degree;  //!< Optional parameter to configure how much degree of clockwise rotation of image for On mode.
    staff::Optional< ::RotateExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RotateExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoSourceConfigurationExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct AudioSourceConfiguration: public ::ConfigurationEntity
  {
    ::ReferenceToken SourceToken;  //!< Token of the Audio Source the configuration applies to
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct IPAddress
  {
    ::IPType Type;  //!< Indicates if the address is an IPv4 or IPv6 address.
    staff::Optional< ::IPv4Address > IPv4Address;  //!< IPv4 address.
    staff::Optional< ::IPv6Address > IPv6Address;  //!< IPv6 address
  };

  struct MulticastConfiguration
  {
    ::IPAddress Address;  //!< The multicast address (if this address is set to 0 no multicast streaming is enaled)
    int Port;  //!< The RTP mutlicast destination port.
    int TTL;  //!< In case of IPv6 the TTL value is assumed as the hop limit.
    bool AutoStart;  //!< Read only property signalling that streaming is persistant.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct VideoEncoderConfiguration: public ::ConfigurationEntity
  {
    ::VideoEncoding Encoding;  //!< Used video codec, either Jpeg, H.264 or Mpeg4
    ::VideoResolution Resolution;  //!< Configured video resolution
    float Quality;  //!< Relative value for the video quantizers and the quality of the video.
    staff::Optional< ::VideoRateControl > RateControl;  //!< Optional element to configure rate control related parameters.
    staff::Optional< ::Mpeg4Configuration > MPEG4;  //!< Optional element to configure Mpeg4 related parameters.
    staff::Optional< ::H264Configuration > H264;  //!< Optional element to configure H.264 related parameters.
    ::MulticastConfiguration Multicast;  //!< Defines the multicast settings that could be used for video streaming.
    staff::duration SessionTimeout;  //!< The rtsp session timeout for the related video stream
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoRateControl
  {
    int FrameRateLimit;  //!< Maximum output framerate in fps.
    int EncodingInterval;  //!< Interval at which images are encoded and transmitted.
    int BitrateLimit;  //!< the maximum output bitrate in kbps
  };

  struct Mpeg4Configuration
  {
    int GovLength;  //!< Determines the interval in which the I-Frames will be coded.
    ::Mpeg4Profile Mpeg4Profile;  //!< the Mpeg4 profile, either simple profile (SP) or advanced simple profile (ASP)
  };

  struct H264Configuration
  {
    int GovLength;  //!< Group of Video frames length.
    ::H264Profile H264Profile;  //!< the H.264 profile, either baseline, main, extended or high
  };

  struct AudioEncoderConfiguration: public ::ConfigurationEntity
  {
    ::AudioEncoding Encoding;  //!< Audio codec used for encoding the audio input (either G.711, G.726 or AAC)
    int Bitrate;  //!< The output bitrate in kbps.
    int SampleRate;  //!< The output sample rate in kHz.
    ::MulticastConfiguration Multicast;  //!< Defines the multicast settings that could be used for video streaming.
    staff::duration SessionTimeout;  //!< The rtsp session timeout for the related audio stream
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct AnalyticsEngineConfiguration
  {
    // *useParentElement: true
    std::list< ::Config > AnalyticsModule;
    staff::Optional< ::AnalyticsEngineConfigurationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RuleEngineConfiguration
  {
    // *useParentElement: true
    std::list< ::Config > Rule;
    staff::Optional< ::RuleEngineConfigurationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct VideoAnalyticsConfiguration: public ::ConfigurationEntity
  {
    ::AnalyticsEngineConfiguration AnalyticsEngineConfiguration;
    ::RuleEngineConfiguration RuleEngineConfiguration;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  //! List of parameters according to the corresponding ItemListDescription.
  /*! Each item in the list shall have a unique name. */
  struct ItemList
  {
    //! Value name pair as defined by the corresponding description.
    struct SimpleItem
    {
      // *isAttribute: true
      std::string Name;  //!< Item name.
      // *isAttribute: true
      staff::anySimpleType Value;  //!< Item value.
    };

    //! Complex value structure.
    struct ElementItem
    {
      // *useParentElement: true
      staff::DataObject tUnnamed0;  //!< XML tree contiaing the element value as defined in the corresponding description.
      // *isAttribute: true
      std::string Name;  //!< Item name.
    };

    // *useParentElement: true
    std::list<struct ::ItemList::SimpleItem> SimpleItem;  //!< Value name pair as defined by the corresponding description.
    // *useParentElement: true
    std::list<struct ::ItemList::ElementItem> ElementItem;  //!< Complex value structure.
    staff::Optional< ::ItemListExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Config
  {
    ::ItemList Parameters;  //!< List of configuration parameters as defined in the correspding description.
    // *isAttribute: true
    std::string Name;  //!< Name of the configuration.
    // *isAttribute: true
    staff::QName Type;  //!< Type of the configuration represented by a unique QName.
  };

  struct ItemListExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct AnalyticsEngineConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct RuleEngineConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZConfiguration: public ::ConfigurationEntity
  {
    ::ReferenceToken NodeToken;  //!< A mandatory reference to the PTZ Node that the PTZ Configuration belongs to.
    staff::Optional<staff::anyURI> DefaultAbsolutePantTiltPositionSpace;  //!< If the PTZ Node supports absolute Pan/Tilt movements, it shall specify one Absolute Pan/Tilt Position Space as default.
    staff::Optional<staff::anyURI> DefaultAbsoluteZoomPositionSpace;  //!< If the PTZ Node supports absolute zoom movements, it shall specify one Absolute Zoom Position Space as default.
    staff::Optional<staff::anyURI> DefaultRelativePanTiltTranslationSpace;  //!< If the PTZ Node supports relative Pan/Tilt movements, it shall specify one RelativePan/Tilt Translation Space as default.
    staff::Optional<staff::anyURI> DefaultRelativeZoomTranslationSpace;  //!< If the PTZ Node supports relative zoom movements, it shall specify one Relative Zoom Translation Space as default.
    staff::Optional<staff::anyURI> DefaultContinuousPanTiltVelocitySpace;  //!< If the PTZ Node supports continuous Pan/Tilt movements, it shall specify one Continuous Pan/Tilt Velocity Space as default.
    staff::Optional<staff::anyURI> DefaultContinuousZoomVelocitySpace;  //!< If the PTZ Node supports continuous zoom movements, it shall specify one Continuous Zoom Velocity Space as default.
    staff::Optional< ::PTZSpeed > DefaultPTZSpeed;  //!< If the PTZ Node supports absolute or relative PTZ movements, it shall specify corresponding default Pan/Tilt and Zoom speeds.
    staff::Optional<staff::duration> DefaultPTZTimeout;  //!< If the PTZ Node supports continuous movements, it shall specify a default timeout, after which the movement stops.
    staff::Optional< ::PanTiltLimits > PanTiltLimits;  //!< The Pan/Tilt limits element should be present for a PTZ Node that supports an absolute Pan/Tilt.
    staff::Optional< ::ZoomLimits > ZoomLimits;  //!< The Zoom limits element should be present for a PTZ Node that supports absolute zoom.
    staff::Optional< ::PTZConfigurationExtension > Extension;
  };

  struct PTZSpeed
  {
    staff::Optional< ::Vector2D > PanTilt;  //!< Pan and tilt speed.
    staff::Optional< ::Vector1D > Zoom;  //!< A zoom speed.
  };

  struct Vector2D
  {
    // *isAttribute: true
    float x;
    // *isAttribute: true
    float y;
    // *isAttribute: true
    staff::Optional<staff::anyURI> space;  //!< Pan/tilt coordinate space selector.
  };

  struct Vector1D
  {
    // *isAttribute: true
    float x;
    // *isAttribute: true
    staff::Optional<staff::anyURI> space;  //!< Pan/tilt coordinate space selector.
  };

  struct Space2DDescription
  {
    staff::anyURI URI;  //!< A URI of coordinate systems.
    ::FloatRange XRange;  //!< A range of x-axis.
    ::FloatRange YRange;  //!< A range of y-axis.
  };

  struct PanTiltLimits
  {
    ::Space2DDescription Range;  //!< A range of pan tilt limits.
  };

  struct Space1DDescription
  {
    staff::anyURI URI;  //!< A URI of coordinate systems.
    ::FloatRange XRange;  //!< A range of x-axis.
  };

  struct ZoomLimits
  {
    ::Space1DDescription Range;  //!< A range of zoom limit
  };

  struct PTZConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::PTControlDirection > PTControlDirection;  //!< Optional element to configure PT Control Direction related features.
    staff::Optional< ::PTZConfigurationExtension2 > Extension;
  };

  struct PTControlDirection
  {
    staff::Optional< ::EFlip > EFlip;  //!< Optional element to configure related parameters for E-Flip.
    staff::Optional< ::Reverse > Reverse;  //!< Optional element to configure related parameters for reversing of PT Control Direction.
    staff::Optional< ::PTControlDirectionExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct EFlip
  {
    ::EFlipMode Mode;  //!< Parameter to enable/disable E-Flip feature.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Reverse
  {
    ::ReverseMode Mode;  //!< Parameter to enable/disable Reverse feature.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTControlDirectionExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZConfigurationExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct MetadataConfiguration: public ::ConfigurationEntity
  {
    staff::Optional< ::PTZFilter > PTZStatus;  //!< optional element to configure which PTZ related data is to include in the metadata stream
    staff::Optional< ::EventSubscription > Events;  //!< Optional element to configure the streaming of events.
    staff::Optional<bool> Analytics;  //!< Defines if data to include from the analytics engine part shall be included in the stream
    ::MulticastConfiguration Multicast;  //!< Defines the multicast settings that could be used for video streaming.
    staff::duration SessionTimeout;  //!< The rtsp session timeout for the related audio stream
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::AnalyticsEngineConfiguration > AnalyticsEngineConfiguration;
    staff::Optional< ::MetadataConfigurationExtension > Extension;
  };

  struct PTZFilter
  {
    bool Status;  //!< True if the metadata stream shall contain the PTZ status (IDLE, MOVING or UNKNOWN)
    bool Position;  //!< True if the metadata stream shall contain the PTZ position
    staff::anyAttribute lsAnyAttributes;
  };

  //! Subcription handling in the same way as base notification subscription.
  struct EventSubscription
  {
    struct SubscriptionPolicy
    {
      // *useParentElement: true
      std::list<staff::DataObject> tUnnamed0;
    };

    staff::Optional< ::FilterType > Filter;
    staff::Optional<struct ::EventSubscription::SubscriptionPolicy> SubscriptionPolicy;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct MetadataConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ProfileExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::AudioOutputConfiguration > AudioOutputConfiguration;  //!< Optional configuration of the Audio output.
    staff::Optional< ::AudioDecoderConfiguration > AudioDecoderConfiguration;  //!< Optional configuration of the Audio decoder.
    staff::Optional< ::ProfileExtension2 > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AudioOutputConfiguration: public ::ConfigurationEntity
  {
    ::ReferenceToken OutputToken;  //!< Token of the phsycial Audio output.
    staff::Optional<staff::anyURI> SendPrimacy;  //!< An audio channel MAY support different types of audio transmission.
    int OutputLevel;  //!< Volume setting of the output.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  //! The Audio Decoder Configuration does not contain any that parameter to configure the decoding .A decoder shall decode every data it receives (according to its capabilities).
  struct AudioDecoderConfiguration: public ::ConfigurationEntity
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ProfileExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoSourceConfigurationOptions
  {
    ::IntRectangleRange BoundsRange;  //!< Supported range for the capturing area.
    // *useParentElement: true
    std::list< ::ReferenceToken > VideoSourceTokensAvailable;  //!< List of physical inputs.
    staff::Optional< ::VideoSourceConfigurationOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct VideoSourceConfigurationOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::RotateOptions > Rotate;  //!< Options of parameters for Rotation feature.
    staff::Optional< ::VideoSourceConfigurationOptionsExtension2 > Extension;
  };

  struct RotateOptions
  {
    // *useParentElement: true
    std::list< ::RotateMode > Mode;  //!< Supported options of Rotate mode parameter.
    staff::Optional< ::IntList > DegreeList;  //!< List of supported degree value for rotation.
    staff::Optional< ::RotateOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RotateOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoSourceConfigurationOptionsExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoEncoderConfigurationOptions
  {
    ::IntRange QualityRange;  //!< Range of the quality values.
    staff::Optional< ::JpegOptions > JPEG;  //!< Optional JPEG encoder settings ranges (See also Extension element).
    staff::Optional< ::Mpeg4Options > MPEG4;  //!< Optional MPEG-4 encoder settings ranges (See also Extension element).
    staff::Optional< ::H264Options > H264;  //!< Optional H.264 encoder settings ranges (See also Extension element).
    staff::Optional< ::VideoEncoderOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct JpegOptions
  {
    // *useParentElement: true
    std::list< ::VideoResolution > ResolutionsAvailable;  //!< List of supported image sizes.
    ::IntRange FrameRateRange;  //!< Supported frame rate in fps (frames per second).
    ::IntRange EncodingIntervalRange;  //!< Supported encoding interval range.
  };

  struct Mpeg4Options
  {
    // *useParentElement: true
    std::list< ::VideoResolution > ResolutionsAvailable;  //!< List of supported image sizes.
    ::IntRange GovLengthRange;  //!< Supported group of Video frames length.
    ::IntRange FrameRateRange;  //!< Supported frame rate in fps (frames per second).
    ::IntRange EncodingIntervalRange;  //!< Supported encoding interval range.
    // *useParentElement: true
    std::list< ::Mpeg4Profile > Mpeg4ProfilesSupported;  //!< List of supported MPEG-4 profiles.
  };

  struct H264Options
  {
    // *useParentElement: true
    std::list< ::VideoResolution > ResolutionsAvailable;  //!< List of supported image sizes.
    ::IntRange GovLengthRange;  //!< Supported group of Video frames length.
    ::IntRange FrameRateRange;  //!< Supported frame rate in fps (frames per second).
    ::IntRange EncodingIntervalRange;  //!< Supported encoding interval range.
    // *useParentElement: true
    std::list< ::H264Profile > H264ProfilesSupported;  //!< List of supported H.264 profiles.
  };

  struct VideoEncoderOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::JpegOptions2 > JPEG;  //!< Optional JPEG encoder settings ranges.
    staff::Optional< ::Mpeg4Options2 > MPEG4;  //!< Optional MPEG-4 encoder settings ranges.
    staff::Optional< ::H264Options2 > H264;  //!< Optional H.264 encoder settings ranges.
    staff::Optional< ::VideoEncoderOptionsExtension2 > Extension;
  };

  struct JpegOptions2: public ::JpegOptions
  {
    ::IntRange BitrateRange;  //!< Supported range of encoded bitrate in kbps.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct Mpeg4Options2: public ::Mpeg4Options
  {
    ::IntRange BitrateRange;  //!< Supported range of encoded bitrate in kbps.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct H264Options2: public ::H264Options
  {
    ::IntRange BitrateRange;  //!< Supported range of encoded bitrate in kbps.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoEncoderOptionsExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct AudioSourceConfigurationOptions
  {
    // *useParentElement: true
    std::list< ::ReferenceToken > InputTokensAvailable;  //!< Tokens of the audio source the configuration can be used for.
    staff::Optional< ::AudioSourceOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AudioSourceOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct AudioEncoderConfigurationOptions
  {
    // *useParentElement: true
    std::list< ::AudioEncoderConfigurationOption > Options;  //!< list of supported AudioEncoderConfigurations
    staff::anyAttribute lsAnyAttributes;
  };

  struct AudioEncoderConfigurationOption
  {
    ::AudioEncoding Encoding;  //!< The enoding used for audio data (either G.711, G.726 or AAC)
    ::IntList BitrateList;  //!< List of supported bitrates in kbps for the specified Encoding
    ::IntList SampleRateList;  //!< List of supported Sample Rates in kHz for the specified Encoding
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZStatusFilterOptions
  {
    bool PanTiltStatusSupported;  //!< True if the device is able to stream pan or tilt status information.
    bool ZoomStatusSupported;  //!< True if the device is able to stream zoom status inforamtion.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional<bool> PanTiltPositionSupported;  //!< True if the device is able to stream the pan or tilt position.
    staff::Optional<bool> ZoomPositionSupported;  //!< True if the device is able to stream zoom position information.
    staff::Optional< ::PTZStatusFilterOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct MetadataConfigurationOptions
  {
    ::PTZStatusFilterOptions PTZStatusFilterOptions;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZStatusFilterOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  //! A layout describes a set of Video windows that are displayed simultaniously on a display.
  struct Layout
  {
    // *useParentElement: true
    std::list< ::PaneLayout > PaneLayout;  //!< List of panes assembling the display layout.
    staff::Optional< ::LayoutExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  //! Representation of a physical video outputs.
  struct VideoOutput: public ::DeviceEntity
  {
    ::Layout Layout;
    staff::Optional< ::VideoResolution > Resolution;  //!< Resolution of the display in Pixel.
    staff::Optional<float> RefreshRate;  //!< Refresh rate of the display in Hertz.
    staff::Optional<float> AspectRatio;  //!< Aspect ratio of the display as physical extent of width divided by height.
    staff::Optional< ::VideoOutputExtension > Extension;
  };

  //! A pane layout describes one Video window of a display.
  /*! It links a pane configuration to a region of the screen. */
  struct PaneLayout
  {
    ::ReferenceToken Pane;  //!< Reference to the configuration of the streaming and coding parameters.
    ::Rectangle Area;  //!< Describes the location and size of the area on the monitor.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct LayoutExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoOutputExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoOutputConfiguration: public ::ConfigurationEntity
  {
    ::ReferenceToken OutputToken;  //!< Token of the Video Output the configuration applies to
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct VideoOutputConfigurationOptions
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct VideoDecoderConfigurationOptions
  {
    staff::Optional< ::JpegDecOptions > JpegDecOptions;  //!< If the device is able to decode Jpeg streams this element describes the supported codecs and configurations
    staff::Optional< ::H264DecOptions > H264DecOptions;  //!< If the device is able to decode H.264 streams this element describes the supported codecs and configurations
    staff::Optional< ::Mpeg4DecOptions > Mpeg4DecOptions;  //!< If the device is able to decode Mpeg4 streams this element describes the supported codecs and configurations
    staff::Optional< ::VideoDecoderConfigurationOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct JpegDecOptions
  {
    // *useParentElement: true
    std::list< ::VideoResolution > ResolutionsAvailable;  //!< List of supported Jpeg Video Resolutions
    ::IntRange SupportedInputBitrate;  //!< Supported Jpeg bitrate range in kbps
    ::IntRange SupportedFrameRate;  //!< Supported Jpeg framerate range in fps
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct H264DecOptions
  {
    // *useParentElement: true
    std::list< ::VideoResolution > ResolutionsAvailable;  //!< List of supported H.264 Video Resolutions
    // *useParentElement: true
    std::list< ::H264Profile > SupportedH264Profiles;  //!< List of supported H264 Profiles (either baseline, main, extended or high)
    ::IntRange SupportedInputBitrate;  //!< Supported H.264 bitrate range in kbps
    ::IntRange SupportedFrameRate;  //!< Supported H.264 framerate range in fps
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Mpeg4DecOptions
  {
    // *useParentElement: true
    std::list< ::VideoResolution > ResolutionsAvailable;  //!< List of supported Mpeg4 Video Resolutions
    // *useParentElement: true
    std::list< ::Mpeg4Profile > SupportedMpeg4Profiles;  //!< List of supported Mpeg4 Profiles (either SP or ASP)
    ::IntRange SupportedInputBitrate;  //!< Supported Mpeg4 bitrate range in kbps
    ::IntRange SupportedFrameRate;  //!< Supported Mpeg4 framerate range in fps
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct VideoDecoderConfigurationOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  //! Representation of a physical audio outputs.
  struct AudioOutput: public ::DeviceEntity
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct AudioOutputConfigurationOptions
  {
    // *useParentElement: true
    std::list< ::ReferenceToken > OutputTokensAvailable;  //!< Tokens of the physical Audio outputs (typically one).
    // *useParentElement: true
    std::list<staff::anyURI> SendPrimacyOptions;  //!< An channel MAY support different types of audio transmission.
    ::IntRange OutputLevelRange;  //!< Minimum and maximum level range supported for this Output.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AudioDecoderConfigurationOptions
  {
    staff::Optional< ::AACDecOptions > AACDecOptions;  //!< If the device is able to decode AAC encoded audio this section describes the supported configurations
    staff::Optional< ::G711DecOptions > G711DecOptions;  //!< If the device is able to decode G711 encoded audio this section describes the supported configurations
    staff::Optional< ::G726DecOptions > G726DecOptions;  //!< If the device is able to decode G726 encoded audio this section describes the supported configurations
    staff::Optional< ::AudioDecoderConfigurationOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AACDecOptions
  {
    ::IntList Bitrate;  //!< List of supported bitrates in kbps
    ::IntList SampleRateRange;  //!< List of supported sample rates in kHz
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct G711DecOptions
  {
    ::IntList Bitrate;  //!< List of supported bitrates in kbps
    ::IntList SampleRateRange;  //!< List of supported sample rates in kHz
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct G726DecOptions
  {
    ::IntList Bitrate;  //!< List of supported bitrates in kbps
    ::IntList SampleRateRange;  //!< List of supported sample rates in kHz
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AudioDecoderConfigurationOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct Transport
  {
    ::TransportProtocol Protocol;  //!< Defines the network protocol for streaming, either UDP=RTP/UDP, RTSP=RTP/RTSP/TCP or HTTP=RTP/RTSP/HTTP/TCP
    staff::Optional< ::Transport > Tunnel;  //!< Optional element to describe further tunnel options.
  };

  struct StreamSetup
  {
    ::StreamType Stream;  //!< Defines if a multicast or unicast stream is requested
    ::Transport Transport;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct MediaUri
  {
    staff::anyURI Uri;  //!< Stable Uri to be used for requesting the media stream
    bool InvalidAfterConnect;  //!< Indicates if the Uri is only valid until the connection is established.
    bool InvalidAfterReboot;  //!< Indicates if the Uri is invalid after a reboot of the device.
    staff::duration Timeout;  //!< Duration how long the Uri is valid.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Scope
  {
    ::ScopeDefinition ScopeDef;  //!< Indicates if the scope is fixed or configurable.
    staff::anyURI ScopeItem;  //!< Scope item URI.
  };

  struct NetworkInterface: public ::DeviceEntity
  {
    bool Enabled;  //!< Indicates whether or not an interface is enabled.
    staff::Optional< ::NetworkInterfaceInfo > Info;  //!< Network interface information
    staff::Optional< ::NetworkInterfaceLink > Link;  //!< Link configuration.
    staff::Optional< ::IPv4NetworkInterface > IPv4;  //!< IPv4 network interface configuration.
    staff::Optional< ::IPv6NetworkInterface > IPv6;  //!< IPv6 network interface configuration.
    staff::Optional< ::NetworkInterfaceExtension > Extension;
  };

  struct NetworkInterfaceInfo
  {
    staff::Optional<std::string> Name;  //!< Network interface name, for example eth0.
    ::HwAddress HwAddress;  //!< Network interface MAC address.
    staff::Optional<int> MTU;  //!< Maximum transmission unit.
  };

  struct NetworkInterfaceConnectionSetting
  {
    bool AutoNegotiation;  //!< Auto negotiation on/off.
    int Speed;  //!< Speed.
    ::Duplex Duplex;  //!< Duplex type, Half or Full.
  };

  struct NetworkInterfaceLink
  {
    ::NetworkInterfaceConnectionSetting AdminSettings;  //!< Configured link settings.
    ::NetworkInterfaceConnectionSetting OperSettings;  //!< Current active link settings.
    ::IANA_IfTypes InterfaceType;  //!< Integer indicating interface type, for example: 6 is ethernet.
  };

  struct IPv4Configuration
  {
    // *useParentElement: true
    std::list< ::PrefixedIPv4Address > Manual;  //!< List of manually added IPv4 addresses.
    staff::Optional< ::PrefixedIPv4Address > LinkLocal;  //!< Link local address.
    staff::Optional< ::PrefixedIPv4Address > FromDHCP;  //!< IPv4 address configured by using DHCP.
    bool DHCP;  //!< Indicates whether or not DHCP is used.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct IPv4NetworkInterface
  {
    bool Enabled;  //!< Indicates whether or not IPv4 is enabled.
    ::IPv4Configuration Config;  //!< IPv4 configuration.
  };

  struct PrefixedIPv4Address
  {
    ::IPv4Address Address;  //!< IPv4 address
    int PrefixLength;  //!< Prefix/submask length
  };

  struct IPv6NetworkInterface
  {
    bool Enabled;  //!< Indicates whether or not IPv6 is enabled.
    staff::Optional< ::IPv6Configuration > Config;  //!< IPv6 configuration.
  };

  struct IPv6Configuration
  {
    staff::Optional<bool> AcceptRouterAdvert;  //!< Indicates whether router advertisment is used.
    ::IPv6DHCPConfiguration DHCP;  //!< DHCP configuration.
    // *useParentElement: true
    std::list< ::PrefixedIPv6Address > Manual;  //!< List of manually entered IPv6 addresses.
    // *useParentElement: true
    std::list< ::PrefixedIPv6Address > LinkLocal;  //!< List of link local IPv6 addresses.
    // *useParentElement: true
    std::list< ::PrefixedIPv6Address > FromDHCP;  //!< List of IPv6 addresses configured by using DHCP.
    // *useParentElement: true
    std::list< ::PrefixedIPv6Address > FromRA;  //!< List of IPv6 addresses configured by using router advertisment.
    staff::Optional< ::IPv6ConfigurationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PrefixedIPv6Address
  {
    ::IPv6Address Address;  //!< IPv6 address
    int PrefixLength;  //!< Prefix/submask length
  };

  struct IPv6ConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct NetworkInterfaceExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    ::IANA_IfTypes InterfaceType;
    // *useParentElement: true
    std::list< ::Dot3Configuration > Dot3;  //!< Extension point prepared for future 802.3 configuration.
    // *useParentElement: true
    std::list< ::Dot11Configuration > Dot11;
    staff::Optional< ::NetworkInterfaceExtension2 > Extension;
  };

  struct Dot3Configuration
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Dot11SecurityConfiguration
  {
    ::Dot11SecurityMode Mode;
    staff::Optional< ::Dot11Cipher > Algorithm;
    staff::Optional< ::Dot11PSKSet > PSK;
    staff::Optional< ::ReferenceToken > Dot1X;
    staff::Optional< ::Dot11SecurityConfigurationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Dot11Configuration
  {
    ::Dot11SSIDType SSID;
    ::Dot11StationMode Mode;
    ::Name Alias;
    ::NetworkInterfaceConfigPriority Priority;
    ::Dot11SecurityConfiguration Security;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Dot11PSKSet
  {
    staff::Optional< ::Dot11PSK > Key;  //!< According to IEEE802.11-2007 H.4.1 the RSNA PSK consists of 256 bits, or 64 octets when represented in hex Either Key or Passphrase shall be given, if both are supplied Key shall be used by the device and Passphrase ignored.
    staff::Optional< ::Dot11PSKPassphrase > Passphrase;  //!< According to IEEE802.11-2007 H.4.1 a pass-phrase is a sequence of between 8 and 63 ASCII-encoded characters and each character in the pass-phrase must have an encoding in the range of 32 to 126 (decimal),inclusive.
    staff::Optional< ::Dot11PSKSetExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Dot11PSKSetExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct Dot11SecurityConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct NetworkInterfaceExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct NetworkProtocol
  {
    ::NetworkProtocolType Name;  //!< Network protocol type string.
    bool Enabled;  //!< Indicates if the protocol is enabled or not.
    // *useParentElement: true
    std::list<int> Port;  //!< The port that is used by the protocol.
    staff::Optional< ::NetworkProtocolExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct NetworkProtocolExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct NetworkHost
  {
    ::NetworkHostType Type;  //!< Network host type: IPv4, IPv6 or DNS.
    staff::Optional< ::IPv4Address > IPv4Address;  //!< IPv4 address.
    staff::Optional< ::IPv6Address > IPv6Address;  //!< IPv6 address.
    staff::Optional< ::DNSName > DNSname;  //!< DNS name.
    staff::Optional< ::NetworkHostExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct NetworkHostExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct HostnameInformation
  {
    bool FromDHCP;  //!< Indicates whether the hostname is obtained from DHCP or not.
    staff::Optional<staff::token> Name;  //!< Indicates the hostname.
    staff::Optional< ::HostnameInformationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct HostnameInformationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct DNSInformation
  {
    bool FromDHCP;  //!< Indicates whether or not DNS information is retrieved from DHCP.
    // *useParentElement: true
    std::list<staff::token> SearchDomain;  //!< Search domain.
    // *useParentElement: true
    std::list< ::IPAddress > DNSFromDHCP;  //!< List of DNS addresses received from DHCP.
    // *useParentElement: true
    std::list< ::IPAddress > DNSManual;  //!< List of manually entered DNS addresses.
    staff::Optional< ::DNSInformationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct DNSInformationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct NTPInformation
  {
    bool FromDHCP;  //!< Indicates if NTP information is to be retrieved by using DHCP.
    // *useParentElement: true
    std::list< ::NetworkHost > NTPFromDHCP;  //!< List of NTP addresses retrieved by using DHCP.
    // *useParentElement: true
    std::list< ::NetworkHost > NTPManual;  //!< List of manually entered NTP addresses.
    staff::Optional< ::NTPInformationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct NTPInformationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct DynamicDNSInformation
  {
    ::DynamicDNSType Type;  //!< Dynamic DNS type.
    staff::Optional< ::DNSName > Name;  //!< DNS name.
    staff::Optional<staff::duration> TTL;  //!< Time to live.
    staff::Optional< ::DynamicDNSInformationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct DynamicDNSInformationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct NetworkInterfaceSetConfiguration
  {
    staff::Optional<bool> Enabled;  //!< Indicates whether or not an interface is enabled.
    staff::Optional< ::NetworkInterfaceConnectionSetting > Link;  //!< Link configuration.
    staff::Optional<int> MTU;  //!< Maximum transmission unit.
    staff::Optional< ::IPv4NetworkInterfaceSetConfiguration > IPv4;  //!< IPv4 network interface configuration.
    staff::Optional< ::IPv6NetworkInterfaceSetConfiguration > IPv6;  //!< IPv6 network interface configuration.
    staff::Optional< ::NetworkInterfaceSetConfigurationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct IPv4NetworkInterfaceSetConfiguration
  {
    staff::Optional<bool> Enabled;  //!< Indicates whether or not IPv4 is enabled.
    // *useParentElement: true
    std::list< ::PrefixedIPv4Address > Manual;  //!< List of manually added IPv4 addresses.
    staff::Optional<bool> DHCP;  //!< Indicates whether or not DHCP is used.
  };

  struct IPv6NetworkInterfaceSetConfiguration
  {
    staff::Optional<bool> Enabled;  //!< Indicates whether or not IPv6 is enabled.
    staff::Optional<bool> AcceptRouterAdvert;  //!< Indicates whether router advertisment is used.
    // *useParentElement: true
    std::list< ::PrefixedIPv6Address > Manual;  //!< List of manually added IPv6 addresses.
    staff::Optional< ::IPv6DHCPConfiguration > DHCP;  //!< DHCP configuration.
  };

  struct NetworkInterfaceSetConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    // *useParentElement: true
    std::list< ::Dot3Configuration > Dot3;
    // *useParentElement: true
    std::list< ::Dot11Configuration > Dot11;
    staff::Optional< ::NetworkInterfaceSetConfigurationExtension2 > Extension;
  };

  struct NetworkInterfaceSetConfigurationExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct NetworkGateway
  {
    // *useParentElement: true
    std::list< ::IPv4Address > IPv4Address;  //!< IPv4 address string.
    // *useParentElement: true
    std::list< ::IPv6Address > IPv6Address;  //!< IPv6 address string.
  };

  struct NetworkZeroConfiguration
  {
    ::ReferenceToken InterfaceToken;  //!< Unique identifier of network interface.
    bool Enabled;  //!< Indicates whether the zero-configuration is enabled or not.
    // *useParentElement: true
    std::list< ::IPv4Address > Addresses;  //!< The zero-configuration IPv4 address(es)
    staff::Optional< ::NetworkZeroConfigurationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct NetworkZeroConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    // *useParentElement: true
    std::list< ::NetworkZeroConfiguration > Additional;  //!< Optional array holding the configuration for the second and possibly further interfaces.
    staff::Optional< ::NetworkZeroConfigurationExtension2 > Extension;
  };

  struct NetworkZeroConfigurationExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct IPAddressFilter
  {
    ::IPAddressFilterType Type;
    // *useParentElement: true
    std::list< ::PrefixedIPv4Address > IPv4Address;
    // *useParentElement: true
    std::list< ::PrefixedIPv6Address > IPv6Address;
    staff::Optional< ::IPAddressFilterExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct IPAddressFilterExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct Dot11Capabilities
  {
    bool TKIP;
    bool ScanAvailableNetworks;
    bool MultipleConfiguration;
    bool AdHocStationMode;
    bool WEP;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Dot11Status
  {
    ::Dot11SSIDType SSID;
    staff::Optional<std::string> BSSID;
    staff::Optional< ::Dot11Cipher > PairCipher;
    staff::Optional< ::Dot11Cipher > GroupCipher;
    staff::Optional< ::Dot11SignalStrength > SignalStrength;
    ::ReferenceToken ActiveConfigAlias;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Dot11AvailableNetworks
  {
    ::Dot11SSIDType SSID;
    staff::Optional<std::string> BSSID;
    // *useParentElement: true
    std::list< ::Dot11AuthAndMangementSuite > AuthAndMangementSuite;  //!< See IEEE802.11 7.3.2.25.2 for details.
    // *useParentElement: true
    std::list< ::Dot11Cipher > PairCipher;
    // *useParentElement: true
    std::list< ::Dot11Cipher > GroupCipher;
    staff::Optional< ::Dot11SignalStrength > SignalStrength;
    staff::Optional< ::Dot11AvailableNetworksExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Dot11AvailableNetworksExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct Capabilities
  {
    staff::Optional< ::AnalyticsCapabilities > Analytics;  //!< Analytics capabilities
    staff::Optional< ::DeviceCapabilities > Device;  //!< Device capabilities
    staff::Optional< ::EventCapabilities > Events;  //!< Event capabilities
    staff::Optional< ::ImagingCapabilities > Imaging;  //!< Imaging capabilities
    staff::Optional< ::MediaCapabilities > Media;  //!< Media capabilities
    staff::Optional< ::PTZCapabilities > PTZ;  //!< PTZ capabilities
    staff::Optional< ::CapabilitiesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AnalyticsCapabilities
  {
    staff::anyURI XAddr;  //!< Analytics service URI.
    bool RuleSupport;  //!< Indicates whether or not rules are supported.
    bool AnalyticsModuleSupport;  //!< Indicates whether or not modules are supported.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct DeviceCapabilities
  {
    staff::anyURI XAddr;  //!< Device service URI.
    staff::Optional< ::NetworkCapabilities > Network;  //!< Network capabilities.
    staff::Optional< ::SystemCapabilities > System;  //!< System capabilities.
    staff::Optional< ::IOCapabilities > IO;  //!< I/O capabilities.
    staff::Optional< ::SecurityCapabilities > Security;  //!< Security capabilities.
    staff::Optional< ::DeviceCapabilitiesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct NetworkCapabilities
  {
    staff::Optional<bool> IPFilter;  //!< Indicates whether or not IP filtering is supported.
    staff::Optional<bool> ZeroConfiguration;  //!< Indicates whether or not zeroconf is supported.
    staff::Optional<bool> IPVersion6;  //!< Indicates whether or not IPv6 is supported.
    staff::Optional<bool> DynDNS;  //!< Indicates whether or not is supported.
    staff::Optional< ::NetworkCapabilitiesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct NetworkCapabilitiesExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional<bool> Dot11Configuration;
    staff::Optional< ::NetworkCapabilitiesExtension2 > Extension;
  };

  struct NetworkCapabilitiesExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct SystemCapabilities
  {
    bool DiscoveryResolve;  //!< Indicates whether or not WS Discovery resolve requests are supported.
    bool DiscoveryBye;  //!< Indicates whether or not WS-Discovery Bye is supported.
    bool RemoteDiscovery;  //!< Indicates whether or not remote discovery, see WS-Discovery, is supported.
    bool SystemBackup;  //!< Indicates whether or not system backup is supported.
    bool SystemLogging;  //!< Indicates whether or not system logging is supported.
    bool FirmwareUpgrade;  //!< Indicates whether or not firmware upgrade is supported.
    // *useParentElement: true
    std::list< ::OnvifVersion > SupportedVersions;  //!< Indicates supported ONVIF version(s).
    staff::Optional< ::SystemCapabilitiesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct OnvifVersion
  {
    int Major;  //!< Major version number.
    int Minor;  //!< Two digit minor version number (e.g.
  };

  struct SystemCapabilitiesExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional<bool> HttpFirmwareUpgrade;
    staff::Optional<bool> HttpSystemBackup;
    staff::Optional<bool> HttpSystemLogging;
    staff::Optional<bool> HttpSupportInformation;
    staff::Optional< ::SystemCapabilitiesExtension2 > Extension;
  };

  struct SystemCapabilitiesExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct IOCapabilities
  {
    staff::Optional<int> InputConnectors;  //!< Number of input connectors.
    staff::Optional<int> RelayOutputs;  //!< Number of relay outputs.
    staff::Optional< ::IOCapabilitiesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct IOCapabilitiesExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct IOCapabilitiesExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional<bool> Auxiliary;
    // *useParentElement: true
    std::list< ::AuxiliaryData > AuxiliaryCommands;
    ::IOCapabilitiesExtension2 Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct SecurityCapabilities
  {
    // *elementName: TLS1.1
    bool TLS1_1;  //!< Indicates whether or not TLS 1.1 is supported.
    // *elementName: TLS1.2
    bool TLS1_2;  //!< Indicates whether or not TLS 1.2 is supported.
    bool OnboardKeyGeneration;  //!< Indicates whether or not onboard key generation is supported.
    bool AccessPolicyConfig;  //!< Indicates whether or not access policy configuration is supported.
    // *elementName: X.509Token
    bool X_509Token;  //!< Indicates whether or not WS-Security X.509 token is supported.
    bool SAMLToken;  //!< Indicates whether or not WS-Security SAML token is supported.
    bool KerberosToken;  //!< Indicates whether or not WS-Security Kerberos token is supported.
    bool RELToken;  //!< Indicates whether or not WS-Security REL token is supported.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::SecurityCapabilitiesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct SecurityCapabilitiesExtension
  {
    // *elementName: TLS1.0
    bool TLS1_0;
    staff::Optional< ::SecurityCapabilitiesExtension2 > Extension;
  };

  struct SecurityCapabilitiesExtension2
  {
    bool Dot1X;
    // *useParentElement: true
    std::list<int> SupportedEAPMethod;  //!< EAP Methods supported by the device.
    bool RemoteUserHandling;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct DeviceCapabilitiesExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct EventCapabilities
  {
    staff::anyURI XAddr;  //!< Event service URI.
    bool WSSubscriptionPolicySupport;  //!< Indicates whether or not WS Subscription policy is supported.
    bool WSPullPointSupport;  //!< Indicates whether or not WS Pull Point is supported.
    bool WSPausableSubscriptionManagerInterfaceSupport;  //!< Indicates whether or not WS Pausable Subscription Manager Interface is supported.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ImagingCapabilities
  {
    staff::anyURI XAddr;  //!< Imaging service URI.
    staff::anyAttribute lsAnyAttributes;
  };

  struct RealTimeStreamingCapabilities
  {
    staff::Optional<bool> RTPMulticast;  //!< Indicates whether or not RTP multicast is supported.
    staff::Optional<bool> RTP_TCP;  //!< Indicates whether or not RTP over TCP is supported.
    staff::Optional<bool> RTP_RTSP_TCP;  //!< Indicates whether or not RTP/RTSP/TCP is supported.
    staff::Optional< ::RealTimeStreamingCapabilitiesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct MediaCapabilities
  {
    staff::anyURI XAddr;  //!< Media service URI.
    ::RealTimeStreamingCapabilities StreamingCapabilities;  //!< Streaming capabilities.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::MediaCapabilitiesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RealTimeStreamingCapabilitiesExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ProfileCapabilities
  {
    int MaximumNumberOfProfiles;  //!< Maximum number of profiles.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct MediaCapabilitiesExtension
  {
    ::ProfileCapabilities ProfileCapabilities;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZCapabilities
  {
    staff::anyURI XAddr;  //!< PTZ service URI.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct CapabilitiesExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::DeviceIOCapabilities > DeviceIO;
    staff::Optional< ::DisplayCapabilities > Display;
    staff::Optional< ::RecordingCapabilities > Recording;
    staff::Optional< ::SearchCapabilities > Search;
    staff::Optional< ::ReplayCapabilities > Replay;
    staff::Optional< ::ReceiverCapabilities > Receiver;
    staff::Optional< ::AnalyticsDeviceCapabilities > AnalyticsDevice;
    staff::Optional< ::CapabilitiesExtension2 > Extensions;
  };

  struct DeviceIOCapabilities
  {
    staff::anyURI XAddr;
    int VideoSources;
    int VideoOutputs;
    int AudioSources;
    int AudioOutputs;
    int RelayOutputs;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct DisplayCapabilities
  {
    staff::anyURI XAddr;
    bool FixedLayout;  //!< Indication that the SetLayout command supports only predefined layouts.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RecordingCapabilities
  {
    staff::anyURI XAddr;
    bool ReceiverSource;
    bool MediaProfileSource;
    bool DynamicRecordings;
    bool DynamicTracks;
    int MaxStringLength;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct SearchCapabilities
  {
    staff::anyURI XAddr;
    bool MetadataSearch;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ReplayCapabilities
  {
    staff::anyURI XAddr;  //!< The address of the replay service.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ReceiverCapabilities
  {
    staff::anyURI XAddr;  //!< The address of the receiver service.
    bool RTP_Multicast;  //!< Indicates whether the device can receive RTP multicast streams.
    bool RTP_TCP;  //!< Indicates whether the device can receive RTP/TCP streams
    bool RTP_RTSP_TCP;  //!< Indicates whether the device can receive RTP/RTSP/TCP streams.
    int SupportedReceivers;  //!< The maximum number of receivers supported by the device.
    int MaximumRTSPURILength;  //!< The maximum allowed length for RTSP URIs.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AnalyticsDeviceCapabilities
  {
    staff::anyURI XAddr;
    staff::Optional<bool> RuleSupport;  //!< Obsolete property.
    staff::Optional< ::AnalyticsDeviceExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AnalyticsDeviceExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct CapabilitiesExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct SystemLog
  {
    staff::Optional< ::AttachmentData > Binary;  //!< The log information as attachment data.
    staff::Optional<std::string> String;  //!< The log information as character data.
  };

  struct AttachmentData
  {
    ::Include Include;
    // *isAttribute: true
    staff::Optional<std::string> contentType;
  };

  struct SupportInformation
  {
    staff::Optional< ::AttachmentData > Binary;  //!< The support information as attachment data.
    staff::Optional<std::string> String;  //!< The support information as character data.
  };

  struct BinaryData
  {
    staff::base64Binary Data;  //!< base64 encoded binary data.
    // *isAttribute: true
    staff::Optional<std::string> contentType;
  };

  struct BackupFile
  {
    std::string Name;
    ::AttachmentData Data;
  };

  struct SystemLogUriList
  {
    // *useParentElement: true
    std::list< ::SystemLogUri > SystemLog;
  };

  struct SystemLogUri
  {
    ::SystemLogType Type;
    staff::anyURI Uri;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  //! General date time inforamtion returned by the GetSystemDateTime method.
  struct SystemDateTime
  {
    ::SetDateTimeType DateTimeType;  //!< Indicates if the time is set manully or through NTP.
    bool DaylightSavings;  //!< Informative indicator whether daylight savings is currently on/off.
    staff::Optional< ::TimeZone > TimeZone;  //!< Timezone information in Posix format.
    staff::Optional< ::DateTime > UTCDateTime;  //!< Current system date and time in UTC format.
    staff::Optional< ::DateTime > LocalDateTime;  //!< Date and time in local format.
    staff::Optional< ::SystemDateTimeExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  //! The TZ format is specified by POSIX, please refer to POSIX 1003.1 section 8.3 Example: Europe, Paris TZ=CET-1CEST,M3.5.0/2,M10.5.0/3 CET = designation for standard time when daylight saving is not in force -1 = offset in hours = negative so 1 hour east of Greenwich meridian CEST = designation when daylight saving is in force ("Central European Summer Time") , = no offset number between code and comma, so default to one hour ahead for daylight saving M3.5.0 = when daylight saving starts = the last Sunday in March (the "5th" week means the last in the month) /2, = the local time when the switch occurs = 2 a.m.
  /*! in this case M10.5.0 = when daylight saving ends = the last Sunday in October. /3, = the local time when the switch occurs = 3 a.m. in this case */
  struct TimeZone
  {
    staff::token TZ;  //!< Posix timezone string.
  };

  struct Time
  {
    int Hour;  //!< Range is 0 to 23.
    int Minute;  //!< Range is 0 to 59.
    int Second;  //!< Range is 0 to 61 (typically 59).
  };

  struct Date
  {
    int Year;
    int Month;  //!< Range is 1 to 12.
    int Day;  //!< Range is 1 to 31.
  };

  struct DateTime
  {
    ::Time Time;
    ::Date Date;
  };

  struct SystemDateTimeExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct RemoteUser
  {
    std::string Username;
    staff::Optional<std::string> Password;
    bool UseDerivedPassword;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct User
  {
    std::string Username;  //!< Username string.
    staff::Optional<std::string> Password;  //!< Password string.
    ::UserLevel UserLevel;  //!< User level string.
    staff::Optional< ::UserExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct UserExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct CertificateGenerationParameters
  {
    staff::Optional<staff::token> CertificateID;
    staff::Optional<std::string> Subject;
    staff::Optional<staff::token> ValidNotBefore;
    staff::Optional<staff::token> ValidNotAfter;
    staff::Optional< ::CertificateGenerationParametersExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct CertificateGenerationParametersExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct Certificate
  {
    staff::token CertificateID;  //!< Certificate id.
    ::BinaryData Certificate;  //!< base64 encoded DER representation of certificate.
  };

  struct CertificateStatus
  {
    staff::token CertificateID;  //!< Certificate id.
    bool Status;  //!< Indicates whether or not a certificate is used in a HTTPS configuration.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct CertificateWithPrivateKey
  {
    staff::Optional<staff::token> CertificateID;
    ::BinaryData Certificate;
    ::BinaryData PrivateKey;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct CertificateInformation
  {
    staff::token CertificateID;
    staff::Optional<std::string> IssuerDN;
    staff::Optional<std::string> SubjectDN;
    staff::Optional< ::CertificateUsage > KeyUsage;
    staff::Optional< ::CertificateUsage > ExtendedKeyUsage;
    staff::Optional<int> KeyLength;
    staff::Optional<std::string> Version;
    staff::Optional<std::string> SerialNum;
    staff::Optional<std::string> SignatureAlgorithm;  //!< Validity Range is from "NotBefore" to "NotAfter"; the corresponding DateTimeRange is from "From" to "Until"
    staff::Optional< ::DateTimeRange > Validity;
    staff::Optional< ::CertificateInformationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct CertificateUsage
  {
    // *useParentElement: true
    std::string tParent;
    // *isAttribute: true
    bool Critical;
  };

  struct DateTimeRange
  {
    staff::dateTime From;
    staff::dateTime Until;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct CertificateInformationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct Dot1XConfiguration
  {
    ::ReferenceToken Dot1XConfigurationToken;
    std::string Identity;
    staff::Optional<std::string> AnonymousID;
    int EAPMethod;  //!< EAP Method type as defined in .
    // *useParentElement: true
    std::list<staff::token> CACertificateID;
    staff::Optional< ::EAPMethodConfiguration > EAPMethodConfiguration;
    staff::Optional< ::Dot1XConfigurationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct EAPMethodConfiguration
  {
    staff::Optional< ::TLSConfiguration > TLSConfiguration;  //!< Confgiuration information for TLS Method.
    staff::Optional<std::string> Password;  //!< Password for those EAP Methods that require a password.
    staff::Optional< ::EapMethodExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct TLSConfiguration
  {
    staff::token CertificateID;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct EapMethodExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct Dot1XConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct GenericEapPwdConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct RelayOutputSettings
  {
    ::RelayMode Mode;  //!< 'Bistable' or 'Monostable'
    staff::duration DelayTime;  //!< Time after which the relay returns to its idle state if it is in monostable mode.
    ::RelayIdleState IdleState;  //!< 'open' or 'closed'
  };

  struct RelayOutput: public ::DeviceEntity
  {
    ::RelayOutputSettings Properties;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct DigitalInput: public ::DeviceEntity
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZSpaces
  {
    // *useParentElement: true
    std::list< ::Space2DDescription > AbsolutePanTiltPositionSpace;  //!< The Generic Pan/Tilt Position space is provided by every PTZ node that supports absolute Pan/Tilt, since it does not relate to a specific physical range.
    // *useParentElement: true
    std::list< ::Space1DDescription > AbsoluteZoomPositionSpace;  //!< The Generic Zoom Position Space is provided by every PTZ node that supports absolute Zoom, since it does not relate to a specific physical range.
    // *useParentElement: true
    std::list< ::Space2DDescription > RelativePanTiltTranslationSpace;  //!< The Generic Pan/Tilt translation space is provided by every PTZ node that supports relative Pan/Tilt, since it does not relate to a specific physical range.
    // *useParentElement: true
    std::list< ::Space1DDescription > RelativeZoomTranslationSpace;  //!< The Generic Zoom Translation Space is provided by every PTZ node that supports relative Zoom, since it does not relate to a specific physical range.
    // *useParentElement: true
    std::list< ::Space2DDescription > ContinuousPanTiltVelocitySpace;  //!< The generic Pan/Tilt velocity space shall be provided by every PTZ node, since it does not relate to a specific physical range.
    // *useParentElement: true
    std::list< ::Space1DDescription > ContinuousZoomVelocitySpace;  //!< The generic zoom velocity space specifies a zoom factor velocity without knowing the underlying physical model.
    // *useParentElement: true
    std::list< ::Space1DDescription > PanTiltSpeedSpace;  //!< The speed space specifies the speed for a Pan/Tilt movement when moving to an absolute position or to a relative translation.
    // *useParentElement: true
    std::list< ::Space1DDescription > ZoomSpeedSpace;  //!< The speed space specifies the speed for a Zoom movement when moving to an absolute position or to a relative translation.
    staff::Optional< ::PTZSpacesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZNode: public ::DeviceEntity
  {
    staff::Optional< ::Name > Name;  //!< A unique identifier that is used to reference PTZ Nodes.
    ::PTZSpaces SupportedPTZSpaces;  //!< A list of Coordinate Systems available for the PTZ Node.
    int MaximumNumberOfPresets;  //!< All preset operations MUST be available for this PTZ Node if one preset is supported.
    bool HomeSupported;  //!< A boolean operator specifying the availability of a home position.
    // *useParentElement: true
    std::list< ::AuxiliaryData > AuxiliaryCommands;  //!< A list of supported Auxiliary commands.
    staff::Optional< ::PTZNodeExtension > Extension;
    // *isAttribute: true
    staff::Optional<bool> FixedHomePosition;  //!< Indication whether the HomePosition of a Node is fixed or it can be changed via the SetHomePosition command.
  };

  struct PTZSpacesExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZPresetTourSupported
  {
    int MaximumNumberOfPresetTours;  //!< Indicates number of preset tours that can be created.
    // *useParentElement: true
    std::list< ::PTZPresetTourOperation > PTZPresetTourOperation;  //!< Indicates which preset tour operations are available for this PTZ Node.
    staff::Optional< ::PTZPresetTourSupportedExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZNodeExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    ::PTZPresetTourSupported SupportedPresetTour;  //!< Detail of supported Preset Tour feature.
    staff::Optional< ::PTZNodeExtension2 > Extension;
  };

  struct PTZPresetTourSupportedExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZNodeExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZConfigurationOptions
  {
    ::PTZSpaces Spaces;  //!< A list of supported coordinate systems including their range limitations.
    ::DurationRange PTZTimeout;  //!< A timeout Range within which Timeouts are accepted by the PTZ Node.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::PTControlDirectionOptions > PTControlDirection;  //!< Supported options for PT Direction Control.
    staff::Optional< ::PTZConfigurationOptions2 > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTControlDirectionOptions
  {
    staff::Optional< ::EFlipOptions > EFlip;  //!< Supported options for EFlip feature.
    staff::Optional< ::ReverseOptions > Reverse;  //!< Supported options for Reverse feature.
    staff::Optional< ::PTControlDirectionOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct EFlipOptions
  {
    // *useParentElement: true
    std::list< ::EFlipMode > Mode;  //!< Options of EFlip mode parameter.
    staff::Optional< ::EFlipOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct EFlipOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ReverseOptions
  {
    // *useParentElement: true
    std::list< ::ReverseMode > Mode;  //!< Options of Reverse mode parameter.
    staff::Optional< ::ReverseOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ReverseOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTControlDirectionOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZConfigurationOptions2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZVector
  {
    staff::Optional< ::Vector2D > PanTilt;  //!< Pan and tilt position.
    staff::Optional< ::Vector1D > Zoom;  //!< A zoom position.
  };

  struct PTZStatus
  {
    staff::Optional< ::PTZVector > Position;  //!< Specifies the absolute position of the PTZ unit together with the Space references.
    staff::Optional< ::PTZMoveStatus > MoveStatus;  //!< Indicates if the Pan/Tilt/Zoom device unit is currently moving, idle or in an unknown state.
    staff::Optional<std::string> Error;  //!< States a current PTZ error.
    staff::dateTime UtcTime;  //!< Specifies the UTC time when this status was generated.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZMoveStatus
  {
    staff::Optional< ::MoveStatus > PanTilt;
    staff::Optional< ::MoveStatus > Zoom;
  };

  struct PTZPreset
  {
    staff::Optional< ::Name > Name;  //!< A list of preset position name.
    staff::Optional< ::PTZVector > PTZPosition;  //!< A list of preset position.
    staff::anyAttribute lsAnyAttributes;
    // *isAttribute: true
    staff::Optional< ::ReferenceToken > token;
  };

  struct PTZPresetTourStatus
  {
    ::PTZPresetTourState State;  //!< Indicates state of this preset tour by Idle/Touring/Paused.
    staff::Optional< ::PTZPresetTourSpot > CurrentTourSpot;  //!< Indicates a tour spot currently staying.
    staff::Optional< ::PTZPresetTourStatusExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZPresetTourStartingCondition
  {
    staff::Optional<int> RecurringTime;  //!< Optional parameter to specify how many times the preset tour is recurred.
    staff::Optional<staff::duration> RecurringDuration;  //!< Optional parameter to specify how long time duration the preset tour is recurred.
    staff::Optional< ::PTZPresetTourDirection > Direction;  //!< Optional parameter to choose which direction the preset tour goes.
    staff::Optional< ::PTZPresetTourStartingConditionExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PresetTour
  {
    staff::Optional< ::Name > Name;  //!< Readable name of the preset tour.
    ::PTZPresetTourStatus Status;  //!< Read only parameters to indicate the status of the preset tour.
    bool AutoStart;  //!< Auto Start flag of the preset tour.
    ::PTZPresetTourStartingCondition StartingCondition;  //!< Parameters to specify the detail behavior of the preset tour.
    // *useParentElement: true
    std::list< ::PTZPresetTourSpot > TourSpot;  //!< A list of detail of touring spots including preset positions.
    staff::Optional< ::PTZPresetTourExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
    // *isAttribute: true
    staff::Optional< ::ReferenceToken > token;  //!< Unique identifier of this preset tour.
  };

  struct PTZPresetTourPresetDetail
  {
    // *choiceId: 0
    staff::Optional< ::ReferenceToken > PresetToken;  //!< Option to specify the preset position with Preset Token defined in advance.
    // *choiceId: 0
    staff::Optional<bool> Home;  //!< Option to specify the preset position with the home position of this PTZ Node.
    // *choiceId: 0
    staff::Optional< ::PTZVector > PTZPosition;  //!< Option to specify the preset position with vector of PTZ node directly.
    // *choiceId: 0
    staff::Optional< ::PTZPresetTourTypeExtension > TypeExtension;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZPresetTourSpot
  {
    ::PTZPresetTourPresetDetail PresetDetail;  //!< Detail definition of preset position of the tour spot.
    staff::Optional< ::PTZSpeed > Speed;  //!< Optional parameter to specify Pan/Tilt and Zoom speed on moving toward this tour spot.
    staff::Optional<staff::duration> StayTime;  //!< Optional parameter to specify time duration of staying on this tour sport.
    staff::Optional< ::PTZPresetTourSpotExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZPresetTourTypeExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZPresetTourSpotExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZPresetTourStatusExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZPresetTourStartingConditionExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZPresetTourExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZPresetTourStartingConditionOptions
  {
    staff::Optional< ::IntRange > RecurringTime;  //!< Supported range of Recurring Time.
    staff::Optional< ::DurationRange > RecurringDuration;  //!< Supported range of Recurring Duration.
    // *useParentElement: true
    std::list< ::PTZPresetTourDirection > Direction;  //!< Supported options for Direction of Preset Tour.
    staff::Optional< ::PTZPresetTourStartingConditionOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZPresetTourPresetDetailOptions
  {
    // *useParentElement: true
    std::list< ::ReferenceToken > PresetToken;  //!< A list of available Preset Tokens for tour spots.
    staff::Optional<bool> Home;  //!< An option to indicate Home postion for tour spots.
    staff::Optional< ::Space2DDescription > PanTiltPositionSpace;  //!< Supported range of Pan and Tilt for tour spots.
    staff::Optional< ::Space1DDescription > ZoomPositionSpace;  //!< Supported range of Zoom for a tour spot.
    staff::Optional< ::PTZPresetTourPresetDetailOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZPresetTourSpotOptions
  {
    ::PTZPresetTourPresetDetailOptions PresetDetail;  //!< Supported options for detail definition of preset position of the tour spot.
    ::DurationRange StayTime;  //!< Supported range of stay time for a tour spot.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZPresetTourOptions
  {
    bool AutoStart;  //!< Indicates whether or not the AutoStart is supported.
    ::PTZPresetTourStartingConditionOptions StartingCondition;  //!< Supported options for Preset Tour Starting Condition.
    ::PTZPresetTourSpotOptions TourSpot;  //!< Supported options for Preset Tour Spot.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PTZPresetTourStartingConditionOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PTZPresetTourPresetDetailOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct FocusStatus
  {
    float Position;  //!< Status of focus position.
    ::MoveStatus MoveStatus;  //!< Status of focus MoveStatus.
    std::string Error;  //!< Error status of focus.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ImagingStatus
  {
    ::FocusStatus FocusStatus;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct BacklightCompensationOptions
  {
    // *useParentElement: true
    std::list< ::WideDynamicMode > Mode;
    ::FloatRange Level;
  };

  struct ExposureOptions
  {
    // *useParentElement: true
    std::list< ::ExposureMode > Mode;
    // *useParentElement: true
    std::list< ::ExposurePriority > Priority;
    ::FloatRange MinExposureTime;
    ::FloatRange MaxExposureTime;
    ::FloatRange MinGain;
    ::FloatRange MaxGain;
    ::FloatRange MinIris;
    ::FloatRange MaxIris;
    ::FloatRange ExposureTime;
    ::FloatRange Gain;
    ::FloatRange Iris;
  };

  struct FocusOptions
  {
    // *useParentElement: true
    std::list< ::AutoFocusMode > AutoFocusModes;
    ::FloatRange DefaultSpeed;
    ::FloatRange NearLimit;
    ::FloatRange FarLimit;
  };

  struct WideDynamicRangeOptions
  {
    // *useParentElement: true
    std::list< ::WideDynamicMode > Mode;
    ::FloatRange Level;
  };

  struct WhiteBalanceOptions
  {
    // *useParentElement: true
    std::list< ::WhiteBalanceMode > Mode;
    ::FloatRange YrGain;
    ::FloatRange YbGain;
  };

  struct ImagingOptions
  {
    ::BacklightCompensationOptions BacklightCompensation;
    ::FloatRange Brightness;
    ::FloatRange ColorSaturation;
    ::FloatRange Contrast;
    ::ExposureOptions Exposure;
    ::FocusOptions Focus;
    // *useParentElement: true
    std::list< ::IrCutFilterMode > IrCutFilterModes;
    ::FloatRange Sharpness;
    ::WideDynamicRangeOptions WideDynamicRange;
    ::WhiteBalanceOptions WhiteBalance;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct FocusMove
  {
    staff::Optional< ::AbsoluteFocus > Absolute;  //!< Parameters for the absolute focus control.
    staff::Optional< ::RelativeFocus > Relative;  //!< Parameters for the relative focus control.
    staff::Optional< ::ContinuousFocus > Continuous;  //!< Parameter for the continuous focus control.
  };

  struct AbsoluteFocus
  {
    float Position;  //!< Position parameter for the absolute focus control.
    staff::Optional<float> Speed;  //!< Speed parameter for the absolute focus control.
  };

  struct RelativeFocus
  {
    float Distance;  //!< Distance parameter for the relative focus control.
    staff::Optional<float> Speed;  //!< Speed parameter for the relative focus control.
  };

  struct ContinuousFocus
  {
    float Speed;  //!< Speed parameter for the Continuous focus control.
  };

  struct MoveOptions
  {
    staff::Optional< ::AbsoluteFocusOptions > Absolute;
    staff::Optional< ::RelativeFocusOptions > Relative;
    staff::Optional< ::ContinuousFocusOptions > Continuous;
  };

  struct AbsoluteFocusOptions
  {
    ::FloatRange Position;  //!< Valid ranges of the position.
    staff::Optional< ::FloatRange > Speed;  //!< Valid ranges of the speed.
  };

  struct RelativeFocusOptions
  {
    ::FloatRange Distance;  //!< Valid ranges of the distance.
    ::FloatRange Speed;  //!< Valid ranges of the speed.
  };

  struct ContinuousFocusOptions
  {
    ::FloatRange Speed;  //!< Valid ranges of the speed.
  };

  struct ImagingStatus20
  {
    staff::Optional< ::FocusStatus20 > FocusStatus20;  //!< Status of focus.
    staff::Optional< ::ImagingStatus20Extension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct FocusStatus20
  {
    float Position;  //!< Status of focus position.
    ::MoveStatus MoveStatus;  //!< Status of focus MoveStatus.
    staff::Optional<std::string> Error;  //!< Error status of focus.
    staff::Optional< ::FocusStatus20Extension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct FocusStatus20Extension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ImagingStatus20Extension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ImagingOptions20
  {
    staff::Optional< ::BacklightCompensationOptions20 > BacklightCompensation;  //!< Valid range of Backlight Compensation.
    staff::Optional< ::FloatRange > Brightness;  //!< Valid range of Brightness.
    staff::Optional< ::FloatRange > ColorSaturation;  //!< Valid range of Color Saturation.
    staff::Optional< ::FloatRange > Contrast;  //!< Valid range of Contrast.
    staff::Optional< ::ExposureOptions20 > Exposure;  //!< Valid range of Exposure.
    staff::Optional< ::FocusOptions20 > Focus;  //!< Valid range of Focus.
    // *useParentElement: true
    std::list< ::IrCutFilterMode > IrCutFilterModes;  //!< Valid range of IrCutFilterModes.
    staff::Optional< ::FloatRange > Sharpness;  //!< Valid range of Sharpness.
    staff::Optional< ::WideDynamicRangeOptions20 > WideDynamicRange;  //!< Valid range of WideDynamicRange.
    staff::Optional< ::WhiteBalanceOptions20 > WhiteBalance;  //!< Valid range of WhiteBalance.
    staff::Optional< ::ImagingOptions20Extension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct BacklightCompensationOptions20
  {
    // *useParentElement: true
    std::list< ::BacklightCompensationMode > Mode;  //!< 'ON' or 'OFF'
    staff::Optional< ::FloatRange > Level;  //!< Level range of BacklightCompensation.
  };

  struct ExposureOptions20
  {
    // *useParentElement: true
    std::list< ::ExposureMode > Mode;  //!< Exposure Mode
    // *useParentElement: true
    std::list< ::ExposurePriority > Priority;  //!< The exposure priority mode (low noise/framerate).
    staff::Optional< ::FloatRange > MinExposureTime;  //!< Valid range of the Minimum ExposureTime.
    staff::Optional< ::FloatRange > MaxExposureTime;  //!< Valid range of the Maximum ExposureTime.
    staff::Optional< ::FloatRange > MinGain;  //!< Valid range of the Minimum Gain.
    staff::Optional< ::FloatRange > MaxGain;  //!< Valid range of the Maximum Gain.
    staff::Optional< ::FloatRange > MinIris;  //!< Valid range of the Minimum Iris.
    staff::Optional< ::FloatRange > MaxIris;  //!< Valid range of the Maximum Iris.
    staff::Optional< ::FloatRange > ExposureTime;  //!< Valid range of the ExposureTime.
    staff::Optional< ::FloatRange > Gain;  //!< Valid range of the Gain.
    staff::Optional< ::FloatRange > Iris;  //!< Valid range of the Iris.
  };

  struct FocusOptions20
  {
    // *useParentElement: true
    std::list< ::AutoFocusMode > AutoFocusModes;  //!< Mode of Auto Focus.
    staff::Optional< ::FloatRange > DefaultSpeed;  //!< Valid range of DefaultSpeed.
    staff::Optional< ::FloatRange > NearLimit;  //!< Valid range of NearLimit.
    staff::Optional< ::FloatRange > FarLimit;  //!< Valid range of FarLimit.
    staff::Optional< ::FocusOptions20Extension > Extension;
  };

  struct FocusOptions20Extension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct WideDynamicRangeOptions20
  {
    // *useParentElement: true
    std::list< ::WideDynamicMode > Mode;
    staff::Optional< ::FloatRange > Level;
  };

  struct WhiteBalanceOptions20
  {
    // *useParentElement: true
    std::list< ::WhiteBalanceMode > Mode;  //!< Mode of WhiteBalance.
    staff::Optional< ::FloatRange > YrGain;
    staff::Optional< ::FloatRange > YbGain;
    staff::Optional< ::WhiteBalanceOptions20Extension > Extension;
  };

  struct WhiteBalanceOptions20Extension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ImagingOptions20Extension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::ImageStabilizationOptions > ImageStabilization;  //!< Options of parameters for Image Stabilization feature.
    staff::Optional< ::ImagingOptions20Extension2 > Extension;
  };

  struct ImageStabilizationOptions
  {
    // *useParentElement: true
    std::list< ::ImageStabilizationMode > Mode;  //!< Supported options of Image Stabilization mode parameter.
    staff::Optional< ::FloatRange > Level;  //!< Wide dynamic range mode (on/off).
    staff::Optional< ::ImageStabilizationOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ImageStabilizationOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ImagingOptions20Extension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct MoveOptions20
  {
    staff::Optional< ::AbsoluteFocusOptions > Absolute;  //!< Valid ranges for the absolute control.
    staff::Optional< ::RelativeFocusOptions20 > Relative;  //!< Valid ranges for the relative control.
    staff::Optional< ::ContinuousFocusOptions > Continuous;  //!< Valid ranges for the continuous control.
  };

  struct RelativeFocusOptions20
  {
    ::FloatRange Distance;  //!< Valid ranges of the distance.
    staff::Optional< ::FloatRange > Speed;  //!< Valid ranges of the speed.
  };

  struct MessageExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct MessageDescription
  {
    staff::Optional< ::ItemListDescription > Source;  //!< Set of tokens producing this message.
    staff::Optional< ::ItemListDescription > Key;  //!< Describes optional message payload parameters that may be used as key.
    staff::Optional< ::ItemListDescription > Data;  //!< Describes the payload of the message.
    staff::Optional< ::MessageDescriptionExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
    // *isAttribute: true
    staff::Optional<bool> IsProperty;  //!< Must be set to true when the described Message relates to a property.
  };

  //! Describes a list of items.
  /*! Each item in the list shall have a unique name.
			The list is designed as linear structure without optional or unbounded elements.
			Use ElementItems only when complex structures are inevitable. */
  struct ItemListDescription
  {
    //! Description of a simple item.
    /*! The type must be of cathegory simpleType (xs:string, xs:integer, xs:float, ...). */
    struct SimpleItemDescription
    {
      // *isAttribute: true
      std::string Name;  //!< Item name.
      // *isAttribute: true
      staff::QName Type;
    };

    //! Description of a complex type.
    /*! The Type must reference a defined type. */
    struct ElementItemDescription
    {
      // *isAttribute: true
      std::string Name;  //!< Item name.
      // *isAttribute: true
      staff::QName Type;  //!< The type of the item.
    };

    // *useParentElement: true
    std::list<struct ::ItemListDescription::SimpleItemDescription> SimpleItemDescription;  //!< Description of a simple item.
    // *useParentElement: true
    std::list<struct ::ItemListDescription::ElementItemDescription> ElementItemDescription;  //!< Description of a complex type.
    staff::Optional< ::ItemListDescriptionExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ItemListDescriptionExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct MessageDescriptionExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct Vector
  {
    // *isAttribute: true
    staff::Optional<float> x;
    // *isAttribute: true
    staff::Optional<float> y;
  };

  struct Polygon
  {
    // *useParentElement: true
    std::list< ::Vector > Point;
  };

  struct Polyline
  {
    // *useParentElement: true
    std::list< ::Vector > Point;
  };

  struct Color
  {
    // *isAttribute: true
    float X;
    // *isAttribute: true
    float Y;
    // *isAttribute: true
    float Z;
    // *isAttribute: true
    staff::Optional<staff::anyURI> Colorspace;
  };

  struct ColorCovariance
  {
    // *isAttribute: true
    float XX;
    // *isAttribute: true
    float YY;
    // *isAttribute: true
    float ZZ;
    // *isAttribute: true
    staff::Optional<float> XY;
    // *isAttribute: true
    staff::Optional<float> XZ;
    // *isAttribute: true
    staff::Optional<float> YZ;
    // *isAttribute: true
    staff::Optional<staff::anyURI> Colorspace;
  };

  struct Appearance
  {
    staff::Optional< ::Transformation > Transformation;
    staff::Optional< ::ShapeDescriptor > Shape;
    staff::Optional< ::ColorDescriptor > Color;
    staff::Optional< ::ClassDescriptor > Class;
    staff::Optional< ::AppearanceExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Transformation
  {
    staff::Optional< ::Vector > Translate;
    staff::Optional< ::Vector > Scale;
    staff::Optional< ::TransformationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct TransformationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ShapeDescriptor
  {
    ::Rectangle BoundingBox;
    ::Vector CenterOfGravity;
    // *useParentElement: true
    std::list< ::Polygon > Polygon;
    staff::Optional< ::ShapeDescriptorExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ShapeDescriptorExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ColorDescriptor
  {
    struct ColorCluster
    {
      ::Color Color;
      staff::Optional<float> Weight;
      staff::Optional< ::ColorCovariance > Covariance;
    };

    // *useParentElement: true
    std::list<struct ::ColorDescriptor::ColorCluster> ColorCluster;
    staff::Optional< ::ColorDescriptorExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ColorDescriptorExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ClassDescriptor
  {
    struct ClassCandidate
    {
      ::ClassType Type;
      float Likelihood;
    };

    // *useParentElement: true
    std::list<struct ::ClassDescriptor::ClassCandidate> ClassCandidate;
    staff::Optional< ::ClassDescriptorExtension > Extension;
  };

  struct ClassDescriptorExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    // *useParentElement: true
    std::list< ::OtherType > OtherTypes;
    staff::Optional< ::ClassDescriptorExtension2 > Extension;
  };

  struct OtherType
  {
    std::string Type;  //!< Object Class Type
    float Likelihood;  //!< A likelihood/probability that the corresponding object belongs to this class.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ClassDescriptorExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AppearanceExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ObjectId
  {
    // *isAttribute: true
    staff::Optional<int> ObjectId;
  };

  struct Object: public ::ObjectId
  {
    staff::Optional< ::Appearance > Appearance;
    staff::Optional< ::Behaviour > Behaviour;
    staff::Optional< ::ObjectExtension > Extension;
  };

  struct Behaviour
  {
    struct Removed
    {
      // *useParentElement: true
      std::list<staff::DataObject> tUnnamed0;
    };

    struct Idle
    {
      // *useParentElement: true
      std::list<staff::DataObject> tUnnamed0;
    };

    staff::Optional<struct ::Behaviour::Removed> Removed;
    staff::Optional<struct ::Behaviour::Idle> Idle;
    staff::Optional< ::BehaviourExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct BehaviourExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ObjectExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct Frame
  {
    staff::Optional< ::PTZStatus > PTZStatus;
    staff::Optional< ::Transformation > Transformation;
    // *useParentElement: true
    std::list< ::Object > Object;
    staff::Optional< ::ObjectTree > ObjectTree;
    staff::Optional< ::FrameExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
    // *isAttribute: true
    staff::dateTime UtcTime;
  };

  struct ObjectTree
  {
    // *useParentElement: true
    std::list< ::Rename > Rename;
    // *useParentElement: true
    std::list< ::Split > Split;
    // *useParentElement: true
    std::list< ::Merge > Merge;
    // *useParentElement: true
    std::list< ::ObjectId > Delete;
    staff::Optional< ::ObjectTreeExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Rename
  {
    ::ObjectId from;
    ::ObjectId to;
  };

  struct Split
  {
    ::ObjectId from;
    // *useParentElement: true
    std::list< ::ObjectId > to;
  };

  struct Merge
  {
    // *useParentElement: true
    std::list< ::ObjectId > from;
    ::ObjectId to;
  };

  struct ObjectTreeExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct FrameExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::Optional< ::MotionInCells > MotionInCells;
    staff::Optional< ::FrameExtension2 > Extension;
  };

  struct MotionInCells
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
    // *isAttribute: true
    int Columns;  //!< Number of columns of the cell grid (x dimension)
    // *isAttribute: true
    int Rows;  //!< Number of rows of the cell grid (y dimension)
    // *isAttribute: true
    staff::base64Binary Cells;  //!< A ‚Äú1‚Äù denotes a cell where motion is detected and a ‚Äú0‚Äù an empty cell.
  };

  struct FrameExtension2
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct ConfigDescription
  {
    //! The analytics modules and rule engine produce Events, which must be listed within the Analytics Module Description.
    /*! In order to do so
						the structure of the Message is defined and consists of three groups: Source, Key, and Data. It is recommended to use SimpleItemDescriptions wherever applicable.
						The name of all Items must be unique within all Items contained in any group of this Message.
						Depending on the component multiple parameters or none may be needed to identify the component uniquely. */
    struct Messages: public ::MessageDescription
    {
      std::string ParentTopic;  //!< The ParentTopic labels the message (e.g.
    };

    ::ItemListDescription Parameters;  //!< List describing the configuration parameters.
    // *useParentElement: true
    std::list<struct ::ConfigDescription::Messages> Messages;  //!< The analytics modules and rule engine produce Events, which must be listed within the Analytics Module Description.
    staff::Optional< ::ConfigDescriptionExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
    // *isAttribute: true
    staff::QName Name;  //!< XML Type of the Configuration (e.g.
  };

  struct ConfigDescriptionExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct SupportedRules
  {
    // *useParentElement: true
    std::list<staff::anyURI> RuleContentSchemaLocation;  //!< Lists the location of all schemas that are referenced in the rules.
    // *useParentElement: true
    std::list< ::ConfigDescription > RuleDescription;  //!< List of rules supported by the Video Analytics configuration..
    staff::Optional< ::SupportedRulesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct SupportedRulesExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct SupportedAnalyticsModules
  {
    // *useParentElement: true
    std::list<staff::anyURI> AnalyticsModuleContentSchemaLocation;  //!< It optionally contains a list of URLs that provide the location of schema files.
    // *useParentElement: true
    std::list< ::ConfigDescription > AnalyticsModuleDescription;
    staff::Optional< ::SupportedAnalyticsModulesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct SupportedAnalyticsModulesExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PolygonConfiguration
  {
    ::Polygon Polygon;  //!< Contains Polygon configuration for rule parameters
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PolylineArray
  {
    // *useParentElement: true
    std::list< ::Polyline > Segment;  //!< Contains array of Polyline
    staff::Optional< ::PolylineArrayExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PolylineArrayExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct PolylineArrayConfiguration
  {
    ::PolylineArray PolylineArray;  //!< Contains PolylineArray configuration data
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct MotionExpression
  {
    std::string Expression;  //!< Motion Expression data structure contains motion expression which is based on Scene Descriptor schema with XPATH syntax.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
    // *isAttribute: true
    staff::Optional<std::string> Type;
  };

  struct MotionExpressionConfiguration
  {
    ::MotionExpression MotionExpression;  //!< Contains Rule MotionExpression configuration
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct CellLayout
  {
    ::Transformation Transformation;  //!< Mapping of the cell grid to the Video frame.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
    // *isAttribute: true
    int Columns;  //!< Number of columns of the cell grid (x dimension)
    // *isAttribute: true
    int Rows;  //!< Number of rows of the cell grid (y dimension)
  };

  // *choiceArrayItem: true
  struct MetadataStreamItem
  {
    // *choiceId: 0
    staff::Optional< ::VideoAnalyticsStream > VideoAnalytics;
    // *choiceId: 0
    staff::Optional< ::PTZStream > PTZ;
    // *choiceId: 0
    staff::Optional< ::EventStream > Event;
    // *choiceId: 0
    staff::Optional< ::MetadataStreamExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  // *choiceArrayItem: true
  struct VideoAnalyticsStreamItem
  {
    // *choiceId: 0
    staff::Optional< ::Frame > Frame;
    // *choiceId: 0
    staff::Optional< ::VideoAnalyticsStreamExtension > Extension;
  };

  struct VideoAnalyticsStreamExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  // *choiceArrayItem: true
  struct PTZStreamItem
  {
    // *choiceId: 0
    staff::Optional< ::PTZStatus > PTZStatus;
    // *choiceId: 0
    staff::Optional< ::PTZStreamExtension > Extension;
  };

  struct PTZStreamExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  // *choiceArrayItem: true
  struct EventStreamItem
  {
    // *choiceId: 0
    staff::Optional< ::NotificationMessageHolderType > NotificationMessage;
    // *choiceId: 0
    staff::Optional< ::EventStreamExtension > Extension;
  };

  struct EventStreamExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct MetadataStreamExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  //! Configuration of the streaming and coding settings of a Video window.
  struct PaneConfiguration
  {
    staff::Optional<std::string> PaneName;  //!< Optional name of the pane configuration.
    staff::Optional< ::ReferenceToken > AudioOutputToken;  //!< If the device has audio outputs, this element contains a pointer to the audio output that is associated with the pane.
    staff::Optional< ::ReferenceToken > AudioSourceToken;  //!< If the device has audio sources, this element contains a pointer to the audio source that is associated with this pane.
    staff::Optional< ::AudioEncoderConfiguration > AudioEncoderConfiguration;  //!< The configuration of the audio encoder including codec, bitrate and sample rate.
    staff::Optional< ::ReferenceToken > ReceiverToken;  //!< A pointer to a Receiver that has the necessary information to receive data from a Transmitter.
    ::ReferenceToken Token;  //!< A unique identifier in the display device.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  //! This type contains the Audio and Video coding capabilities of a display service.
  struct CodingCapabilities
  {
    staff::Optional< ::AudioEncoderConfigurationOptions > AudioEncodingCapabilities;  //!< If the device supports audio encoding this section describes the supported codecs and their configuration.
    staff::Optional< ::AudioDecoderConfigurationOptions > AudioDecodingCapabilities;  //!< If the device supports audio decoding this section describes the supported codecs and their settings.
    ::VideoDecoderConfigurationOptions VideoDecodingCapabilities;  //!< This section describes the supported video codesc and their configuration.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  //! The options supported for a display layout.
  struct LayoutOptions
  {
    // *useParentElement: true
    std::list< ::PaneLayoutOptions > PaneLayoutOptions;  //!< Lists the possible Pane Layouts of the Video Output
    staff::Optional< ::LayoutOptionsExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  //! Description of a pane layout describing a complete display layout.
  struct PaneLayoutOptions
  {
    // *useParentElement: true
    std::list< ::Rectangle > Area;  //!< List of areas assembling a layout.
    staff::Optional< ::PaneOptionExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct PaneOptionExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct LayoutOptionsExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  //! Describes the configuration of a receiver.
  struct ReceiverConfiguration
  {
    ::ReceiverMode Mode;  //!< The following connection modes are defined:
    staff::anyURI MediaUri;  //!< Details of the URI to which the receiver should connect.
    ::StreamSetup StreamSetup;  //!< Stream connection parameters.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  //! Description of a receiver, including its token and configuration.
  struct Receiver
  {
    ::ReferenceToken Token;  //!< Unique identifier of the receiver.
    ::ReceiverConfiguration Configuration;  //!< Describes the configuration of the receiver.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  //! Contains information about a receiver's current state.
  struct ReceiverStateInformation
  {
    ::ReceiverState State;  //!< The connection state of the receiver may have one of the following states:
    bool AutoCreated;  //!< Indicates whether or not the receiver was created automatically.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct SourceReference
  {
    ::ReferenceToken Token;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
    // *defaultValue: http://www.onvif.org/ver10/schema/Receiver
    // *isAttribute: true
    staff::Optional<staff::anyURI> Type;

    SourceReference():
      Type("http://www.onvif.org/ver10/schema/Receiver")
    {
    }
  };

  struct RecordingSummary
  {
    staff::dateTime DataFrom;  //!< The earliest point in time where there is recorded data on the device.
    staff::dateTime DataUntil;  //!< The most recent point in time where there is recorded data on the device.
    int NumberRecordings;  //!< The device contains this many recordings.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  //! A structure for defining a limited scope when searching in recorded data.
  struct SearchScope
  {
    // *useParentElement: true
    std::list< ::SourceReference > IncludedSources;  //!< A list of sources that are included in the scope.
    // *useParentElement: true
    std::list< ::RecordingReference > IncludedRecordings;  //!< A list of recordings that are included in the scope.
    staff::Optional< ::XPathExpression > RecordingInformationFilter;  //!< An xpath expression used to specify what recordings to search.
    staff::Optional< ::SearchScopeExtension > Extension;  //!< Extension point
    staff::anyAttribute lsAnyAttributes;
  };

  struct SearchScopeExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct EventFilter: public ::FilterType
  {
  };

  struct PTZPositionFilter
  {
    ::PTZVector MinPosition;  //!< The lower boundary of the PTZ volume to look for.
    ::PTZVector MaxPosition;  //!< The upper boundary of the PTZ volume to look for.
    bool EnterOrExit;  //!< If true, search for when entering the specified PTZ volume.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct MetadataFilter
  {
    ::XPathExpression MetadataStreamFilter;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct FindRecordingResultList
  {
    ::SearchState SearchState;  //!< The state of the search when the result is returned.
    // *useParentElement: true
    std::list< ::RecordingInformation > RecordingInformation;  //!< A RecordingInformation structure for each found recording matching the search.
  };

  //! A set of informative desciptions of a data source.
  /*! The Search searvice allows a client to filter on recordings based on information in this structure. */
  struct RecordingSourceInformation
  {
    staff::anyURI SourceId;  //!< Identifier for the source chosen by the client that creates the structure.
    ::Name Name;  //!< Informative user readable name of the source, e.g.
    ::Description Location;  //!< Informative description of the physical location of the source, e.g.
    ::Description Description;  //!< Informative description of the source.
    staff::anyURI Address;  //!< URI provided by the service supplying data to be recorded.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RecordingInformation
  {
    ::RecordingReference RecordingToken;
    ::RecordingSourceInformation Source;  //!< Information about the source of the recording.
    staff::Optional<staff::dateTime> EarliestRecording;
    staff::Optional<staff::dateTime> LatestRecording;
    ::Description Content;
    // *useParentElement: true
    std::list< ::TrackInformation > Track;  //!< Basic information about the track.
    ::RecordingStatus RecordingStatus;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct TrackInformation
  {
    ::TrackReference TrackToken;
    ::TrackType TrackType;  //!< Type of the track: "Video", "Audio" or "Metadata".
    ::Description Description;  //!< Informative description of the contents of the track.
    staff::dateTime DataFrom;  //!< The start date and time of the oldest recorded data in the track.
    staff::dateTime DataTo;  //!< The stop date and time of the newest recorded data in the track.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct FindEventResultList
  {
    ::SearchState SearchState;  //!< The state of the search when the result is returned.
    // *useParentElement: true
    std::list< ::FindEventResult > Result;  //!< A FindEventResult structure for each found event matching the search.
  };

  struct FindEventResult
  {
    ::RecordingReference RecordingToken;  //!< The recording where this event was found.
    ::TrackReference TrackToken;  //!< A reference to the track where this event was found.
    staff::dateTime Time;  //!< The time when the event occured.
    ::NotificationMessageHolderType Event;  //!< The description of the event.
    bool StartStateEvent;  //!< If true, indicates that the event is a virtual event generated for this particular search session to give the state of a property at the start time of the search.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct FindPTZPositionResultList
  {
    ::SearchState SearchState;  //!< The state of the search when the result is returned.
    // *useParentElement: true
    std::list< ::FindPTZPositionResult > Result;  //!< A FindPTZPositionResult structure for each found PTZ position matching the search.
  };

  struct FindPTZPositionResult
  {
    ::RecordingReference RecordingToken;  //!< A reference to the recording containing the PTZ position.
    ::TrackReference TrackToken;  //!< A reference to the metadata track containing the PTZ position.
    staff::dateTime Time;  //!< The time when the PTZ position was valid.
    ::PTZVector Position;  //!< The PTZ position.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct FindMetadataResultList
  {
    ::SearchState SearchState;  //!< The state of the search when the result is returned.
    // *useParentElement: true
    std::list< ::FindMetadataResult > Result;  //!< A FindMetadataResult structure for each found set of Metadata matching the search.
  };

  struct FindMetadataResult
  {
    ::RecordingReference RecordingToken;  //!< A reference to the recording containing the metadata.
    ::TrackReference TrackToken;  //!< A reference to the metadata track containing the matching metadata.
    staff::dateTime Time;  //!< The point in time when the matching metadata occurs in the metadata track.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  //! A set of media attributes valid for a recording at a point in time or for a time interval.
  struct MediaAttributes
  {
    ::RecordingReference RecordingToken;  //!< A reference to the recording that has these attributes.
    // *useParentElement: true
    std::list< ::TrackAttributes > TrackAttributes;  //!< A set of attributes for each track.
    staff::dateTime From;  //!< The attributes are valid from this point in time in the recording.
    staff::dateTime Until;  //!< The attributes are valid until this point in time in the recording.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct TrackAttributes
  {
    ::TrackInformation TrackInformation;  //!< The basic information about the track.
    staff::Optional< ::VideoAttributes > VideoAttributes;  //!< If the track is a video track, exactly one of this structure shall be present and contain the video attributes.
    staff::Optional< ::AudioAttributes > AudioAttributes;  //!< If the track is an audio track, exactly one of this structure shall be present and contain the audio attributes.
    staff::Optional< ::MetadataAttributes > MetadataAttributes;  //!< If the track is an metadata track, exactly one of this structure shall be present and contain the metadata attributes.
    staff::Optional< ::TrackAttributesExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct VideoAttributes
  {
    staff::Optional<int> Bitrate;  //!< Average bitrate in kbps.
    int Width;  //!< The width of the video in pixels.
    int Height;  //!< The height of the video in pixels.
    ::VideoEncoding Encoding;  //!< Used video codec, either Jpeg, H.264 or Mpeg4
    float Framerate;  //!< Average framerate in frames per second.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AudioAttributes
  {
    staff::Optional<int> Bitrate;  //!< The bitrate in kbps.
    ::AudioEncoding Encoding;  //!< Audio codec used for encoding the audio (either G.711, G.726 or AAC)
    int Samplerate;  //!< The sample rate in kHz.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct MetadataAttributes
  {
    bool CanContainPTZ;  //!< Indicates that there can be PTZ data in the metadata track in the specified time interval.
    bool CanContainAnalytics;  //!< Indicates that there can be analytics data in the metadata track in the specified time interval.
    bool CanContainNotifications;  //!< Indicates that there can be notifications in the metadata track in the specified time interval.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct TrackAttributesExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct RecordingConfiguration
  {
    ::RecordingSourceInformation Source;  //!< Information about the source of the recording.
    ::Description Content;  //!< Informative description of the source.
    staff::duration MaximumRetentionTime;  //!< Sspecifies the maximum time that data in any track within the recording shall be stored.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct TrackConfiguration
  {
    ::TrackType TrackType;  //!< Type of the track.
    ::Description Description;  //!< Informative description of the track.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct GetTracksResponseList
  {
    // *useParentElement: true
    std::list< ::GetTracksResponseItem > Track;  //!< Configuration of a track.
    staff::anyAttribute lsAnyAttributes;
  };

  struct GetRecordingsResponseItem
  {
    ::RecordingReference RecordingToken;  //!< Token of the recording.
    ::RecordingConfiguration Configuration;  //!< Configuration of the recording.
    ::GetTracksResponseList Tracks;  //!< List of tracks.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct GetTracksResponseItem
  {
    ::TrackReference TrackToken;  //!< Token of the track.
    ::TrackConfiguration Configuration;  //!< Configuration of the track.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RecordingJobConfiguration
  {
    ::RecordingReference RecordingToken;  //!< Identifies the recording to which this job shall store the received data.
    ::RecordingJobMode Mode;  //!< The mode of the job.
    int Priority;  //!< This shall be a positive number.
    // *useParentElement: true
    std::list< ::RecordingJobSource > Source;  //!< Source of the recording.
    staff::Optional< ::RecordingJobConfigurationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RecordingJobSource
  {
    staff::Optional< ::SourceReference > SourceToken;  //!< This field shall be a reference to the source of the data.
    staff::Optional<bool> AutoCreateReceiver;  //!< If this field is TRUE, and if the SourceToken is omitted, the device shall create a receiver object (through the receiver service) and assign the ReceiverReference to the SourceToken field.
    // *useParentElement: true
    std::list< ::RecordingJobTrack > Tracks;  //!< List of tracks associated with the recording.
    staff::Optional< ::RecordingJobSourceExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RecordingJobTrack
  {
    std::string SourceTag;  //!< If the received RTSP stream contains multiple tracks of the same type, the SourceTag differentiates between those Tracks.
    ::TrackReference Destination;  //!< The destination is the tracktoken of the track to which the device shall store the received data.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RecordingJobSourceExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct RecordingJobConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct RecordingJobStateInformation
  {
    ::RecordingReference RecordingToken;  //!< Identification of the recording that the recording job records to.
    ::RecordingJobState State;  //!< Holds the aggregated state over the whole RecordingJobInformation structure.
    // *useParentElement: true
    std::list< ::RecordingJobStateSource > Sources;  //!< Identifies the data source of the recording job.
    staff::Optional< ::RecordingJobStateInformationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RecordingJobStateTracks
  {
    // *useParentElement: true
    std::list< ::RecordingJobStateTrack > Track;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RecordingJobStateSource
  {
    ::SourceReference SourceToken;  //!< Identifies the data source of the recording job.
    ::RecordingJobState State;  //!< Holds the aggregated state over all substructures of RecordingJobStateSource.
    ::RecordingJobStateTracks Tracks;  //!< List of track items.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RecordingJobStateTrack
  {
    std::string SourceTag;  //!< Identifies the track of the data source that provides the data.
    ::TrackReference Destination;  //!< Indicates the destination track.
    staff::Optional<std::string> Error;  //!< Optionally holds an implementation defined string value that describes the error.
    ::RecordingJobState State;  //!< Provides the job state of the track.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct RecordingJobStateInformationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct GetRecordingJobsResponseItem
  {
    ::RecordingJobReference JobToken;
    ::RecordingJobConfiguration JobConfiguration;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  //! Configuration parameters for the replay service.
  struct ReplayConfiguration
  {
    staff::duration SessionTimeout;  //!< The RTSP session timeout.
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AnalyticsDeviceEngineConfiguration
  {
    // *useParentElement: true
    std::list< ::EngineConfiguration > EngineConfiguration;
    staff::Optional< ::AnalyticsDeviceEngineConfigurationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AnalyticsEngine: public ::ConfigurationEntity
  {
    ::AnalyticsDeviceEngineConfiguration AnalyticsEngineConfiguration;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct AnalyticsEngineInputInfo
  {
    staff::Optional< ::Config > InputInfo;
    staff::Optional< ::AnalyticsEngineInputInfoExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct EngineConfiguration
  {
    ::VideoAnalyticsConfiguration VideoAnalyticsConfiguration;
    ::AnalyticsEngineInputInfo AnalyticsEngineInputInfo;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AnalyticsEngineInputInfoExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct AnalyticsDeviceEngineConfigurationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct SourceIdentification
  {
    std::string Name;
    // *useParentElement: true
    std::list< ::ReferenceToken > Token;
    staff::Optional< ::SourceIdentificationExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct MetadataInput
  {
    // *useParentElement: true
    std::list< ::Config > MetadataConfig;
    staff::Optional< ::MetadataInputExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AnalyticsEngineInput: public ::ConfigurationEntity
  {
    ::SourceIdentification SourceIdentification;
    ::VideoEncoderConfiguration VideoInput;
    ::MetadataInput MetadataInput;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct SourceIdentificationExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct MetadataInputExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct AnalyticsEngineControl: public ::ConfigurationEntity
  {
    ::ReferenceToken EngineToken;  //!< Token of the analytics engine (AnalyticsEngine) being controlled.
    ::ReferenceToken EngineConfigToken;  //!< Token of the analytics engine configuration (VideoAnalyticsConfiguration) in effect.
    // *useParentElement: true
    std::list< ::ReferenceToken > InputToken;  //!< Tokens of the input (AnalyticsEngineInput) configuration applied.
    // *useParentElement: true
    std::list< ::ReferenceToken > ReceiverToken;  //!< Tokens of the receiver providing media input data.
    staff::Optional< ::MulticastConfiguration > Multicast;
    ::Config Subscription;
    ::ModeOfOperation Mode;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
  };

  struct AnalyticsState
  {
    staff::Optional<std::string> Error;
    std::string State;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct AnalyticsStateInformation
  {
    ::ReferenceToken AnalyticsEngineControlToken;  //!< Token of the control object whose status is requested.
    ::AnalyticsState State;
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  //! Action Engine Event Payload data structure contains the information about the ONVIF command invocations.
  /*! Since this event could be generated by other or proprietary actions, the command invocation specific fields are defined as optional and additional extension mechanism is provided for future or additional action definitions. */
  struct ActionEngineEventPayload
  {
    staff::Optional< ::Envelope > RequestInfo;  //!< Request Message
    staff::Optional< ::Envelope > ResponseInfo;  //!< Response Message
    staff::Optional< ::Fault > Fault;  //!< Fault Message
    staff::Optional< ::ActionEngineEventPayloadExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
  };

  struct ActionEngineEventPayloadExtension
  {
    // *useParentElement: true
    std::list<staff::DataObject> tUnnamed0;
    staff::anyAttribute lsAnyAttributes;
  };

  struct Message
  {
    staff::Optional< ::ItemList > Source;  //!< Token value pairs that triggered this message.
    staff::Optional< ::ItemList > Key;
    staff::Optional< ::ItemList > Data;
    staff::Optional< ::MessageExtension > Extension;
    staff::anyAttribute lsAnyAttributes;
    // *isAttribute: true
    staff::dateTime UtcTime;
    // *isAttribute: true
    staff::Optional< ::PropertyOperation > PropertyOperation;
  };


#endif // _onvif_h_

