// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Client skeleton

#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <string>


#include <boost/array.hpp>
#include <boost/asio.hpp>

#include "app.h"
#include "device/getsystemdateandtime.h"
#include "device/envelope.h"
#include "onv.h"
#include "src/communication/tcpasyncclient.h"
#include "src/communication/udpsender.h"
#include "src/communication/udpreceiver.h"
#include "helper/xmlhelper.h"
#include "helper/authenticator.h"


// the following macro eliminates the attributes
//BOOST_CLASS_IMPLEMENTATION(GetSystemDateAndTime, object_serializable)

int main(int argc, char* argv[])
{

    Authenticator *auth = new Authenticator();
    std::string token[4];
    auth->genToken("admin","pass",token);

    delete auth;

    try {

        XmlHelper *xmlHelper = new XmlHelper;
        QDomDocument docAuthHeader = xmlHelper->loadXml("xml/auth.xml");
        QDomDocument docDiscover = xmlHelper->loadXml("xml/discover.xml");
        QDomDocument docGetSystemDateAndTime = xmlHelper->loadXml("xml/device.GetSystemDateAndTime.xml");
        QDomDocument docGetUsers = xmlHelper->loadXml("xml/getUsers.xml");
        delete xmlHelper;

        boost::asio::io_service io_service;
        boost::asio::io_service io_service_tcp;
        boost::asio::io_service io_service_getUsers;

//        UdpSender s(io_service, boost::asio::ip::address::from_string("239.255.255.250"), docDiscover.toString().toStdString());
//        io_service.run();
//        io_service.stop();

        ///---Kompletter, funktionierender Aufruf von GetSysDateTime

        docGetSystemDateAndTime.elementsByTagName("SOAP-ENV:Envelope").at(0).appendChild((docAuthHeader.elementsByTagName("s:Header").at(0)));

        docGetSystemDateAndTime.elementsByTagName("Username").at(0).firstChild().setNodeValue(token[0].data());
        docGetSystemDateAndTime.elementsByTagName("Password").at(0).firstChild().setNodeValue(token[1].data());
        docGetSystemDateAndTime.elementsByTagName("Nonce").at(0).firstChild().setNodeValue(token[2].data());
        docGetSystemDateAndTime.elementsByTagName("Created").at(0).firstChild().setNodeValue(token[3].data());

        TcpAsyncClient c(io_service_tcp, "192.168.1.200", "/onvif/device_service", docGetSystemDateAndTime.toString().toStdString());
        io_service_tcp.run();
        io_service_tcp.stop();

        ///------


        ///---Hei√üt nur hier soap12:Envelope ....... Kompletter, funktionierender Aufruf von GetUsers
//        docGetUsers.elementsByTagName("soap12:Envelope").at(0).appendChild((docAuthHeader.elementsByTagName("s:Header").at(0)));

//        docGetUsers.elementsByTagName("Username").at(0).firstChild().setNodeValue(token[0].data());
//        docGetUsers.elementsByTagName("Password").at(0).firstChild().setNodeValue(token[1].data());
//        docGetUsers.elementsByTagName("Nonce").at(0).firstChild().setNodeValue(token[2].data());
//        docGetUsers.elementsByTagName("Created").at(0).firstChild().setNodeValue(token[3].data());



        //std::cout << docGetUsers.toString().toStdString() << std::endl;


//        TcpAsyncClient cGetUsers(io_service_getUsers, "192.168.1.200", "/onvif/device_service", docGetUsers.toString().toStdString());
//        io_service_getUsers.run();
//        io_service_getUsers.stop();

           ///-----------------------------


//        std::ofstream ofs("filename.xml");
//        boost::archive::xml_oarchive oa(ofs);

//        std::ostringstream oss;

//        // the flag no_header eliminates the heading lines
//        unsigned int flags = boost::archive::no_header;

//        boost::archive::xml_oarchive oa(oss, flags);

//        SOAPENV::Envelope *envelope = new SOAPENV::Envelope();
//        oa << BOOST_SERIALIZATION_NVP(envelope);



        //GetSystemDateAndTime *gsdt = new GetSystemDateAndTime(1, 2, 3.0);
        //oa << BOOST_SERIALIZATION_NVP(gsdt);

        //std::cout << oss.str() << std::endl;

        //delete gsdt;
        //delete envelope;

    }
    catch (std::exception& e)
    {
        std::cout << "Exception: " << e.what() << "\n";
    }
}


/*

int main(int argc, char* argv[])
{

    // Send WS-Discovery Probe, collect the responses and then
    // process the responses.
        //probematch_type probematcheslist[]={};
    std::list<ONVIF::probematch> probematcheslist;

    // Send probe. See chapter 4.3.1 for details
    ONVIF::probe probe = ONVIF::DiscoverySendProbe("dn:NetworkVideoTransmitter", "onvif://www.onvif.org");

    // Wait a while for responses
    //while (data_available_and_not_timeout(probe.net_handle))
    for(int i=0; i<500; i++) //Quick 'n Dirty
    {
        // This fetch next probe match so that we can put it into the list
        // See chapter 4.3.2 for details
        ONVIF::probematch probematch = ONVIF::DiscoveryReadResponse(probe);

        // Store info about the match, first check for duplicates
//        if (!in_list(probematcheslist, probematch))
//        {
//            add_to_list(probematcheslist, probematch);
//        }

        //Spare much work: Use a Map.
        bool inList=false;
        for (std::list<ONVIF::probematch>::const_iterator iterator = probematcheslist.begin(), end = probematcheslist.end(); iterator != end; iterator++) {
            if(probematch.endpointAddress.compare(iterator->endpointAddress)){
                inList=true;
                break;
            }
        }
        if(!inList)
            probematcheslist.push_back(probematch);
    }

    // Process the responses, see chapter 5.1.3 for details.
    for (std::list<ONVIF::probematch>::const_iterator iterator = probematcheslist.begin(), end = probematcheslist.end(); iterator != end; iterator++)
    {
        ONVIF::ProcessMatch(*iterator);
    }

  return 0;
}
*/

