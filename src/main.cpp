// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Client skeleton

#include <memory>
#include <rise/common/Log.h>
#include <staff/common/Exception.h>
#include <staff/client/ServiceFactory.h>
#include "devicemgmt.h"
#include "onvif.h"
#include "xmlmime.h"
#include ".h"
#include "b.h"
#include "ws_addr.h"
#include "bf.h"
#include "xml.h"
#include "t.h"
#include "include.h"
#include <boost/asio.hpp>

#include <iostream>
#include <boost/array.hpp>

#include "app.h"


//
// receiver.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2008 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <string>
#include <map>

//#include "udpreceiver.h"
#include "onv.h"
#include "udpsender.h"

int main(int argc, char* argv[])
{
    boost::asio::io_service io_service;
    UdpSender s(io_service, boost::asio::ip::address::from_string("239.255.255.250"));
    io_service.run();
}


/*

int main(int argc, char* argv[])
{

    // Send WS-Discovery Probe, collect the responses and then
    // process the responses.
        //probematch_type probematcheslist[]={};
    std::list<ONVIF::probematch> probematcheslist;

    // Send probe. See chapter 4.3.1 for details
    ONVIF::probe probe = ONVIF::DiscoverySendProbe("dn:NetworkVideoTransmitter", "onvif://www.onvif.org");

    // Wait a while for responses
    //while (data_available_and_not_timeout(probe.net_handle))
    for(int i=0; i<500; i++) //Quick 'n Dirty
    {
        // This fetch next probe match so that we can put it into the list
        // See chapter 4.3.2 for details
        ONVIF::probematch probematch = ONVIF::DiscoveryReadResponse(probe);

        // Store info about the match, first check for duplicates
//        if (!in_list(probematcheslist, probematch))
//        {
//            add_to_list(probematcheslist, probematch);
//        }

        //Spare much work: Use a Map.
        bool inList=false;
        for (std::list<ONVIF::probematch>::const_iterator iterator = probematcheslist.begin(), end = probematcheslist.end(); iterator != end; iterator++) {
            if(probematch.endpointAddress.compare(iterator->endpointAddress)){
                inList=true;
                break;
            }
        }
        if(!inList)
            probematcheslist.push_back(probematch);
    }

    // Process the responses, see chapter 5.1.3 for details.
    for (std::list<ONVIF::probematch>::const_iterator iterator = probematcheslist.begin(), end = probematcheslist.end(); iterator != end; iterator++)
    {
        ONVIF::ProcessMatch(*iterator);
    }

  return 0;
}
*/

